---
layout: post
title:  "JS总结"
date:   2018-09-19
tags:  js
color: 'rgb(154,133,255)'


---

#### 1.本地缓存几种方式？区别

- 1.coolie
    - 大小：4k
    - 获取方式：每次请求都会携带cookie
    
    - 声明周期：如果不设置过期时间，默认是会话级别的cookie，浏览器关闭就失效，可以设置过期时间
        document.coolie="name=zs&max-age=60*60*7"
    - cookie还有路径问题：子目录可以访问父目录的cookie，父目录无法访问子目录的cookie，通常设置cookie的路径是根目录
    - 以后设置cookie，不止要设置过期时间，还要设置路径为：path=、，根路径下的coolie所有页面都能访问,以后不常用

```js
document.cookie="age=18"
```      

        
- 2.Local Storage
 
    - 大小：5m左右
    - 获取方式：必须手动获取，自动携带，getltem

```js
    LocalStorage.setItem("username","cc");
    LocalStorage.getItem("username");//cc
    
    var obj={
        name:"hucc",
        age:18
    }
    LocalStorage.setItem(obj,JSON.Stringify(obj));
    LocalStorage.getItem(obj);
    声明周期：关闭浏览器就失效，多窗口不共享
```   
-  3.Session Storage
    - 大小：5m左右
    
    - 获取方式：必须手动获取，自动携带，getItem
    
    - 声明周期：只要不手动清除，永久存在，多窗口功效
#### 2、数组的内置方法

    slice（begin，end）从begin开始，到end结束，不包含end，截取数组的一部分，放到一个新数组中返回，原数组不变
    
    splice 最牛逼的方法，拼接
    可以在任意位置增加元素或删除元素，获取替换元素

```js   
    //第一个参数：起始位置
    //第二个参数:删除的个数
    //第三个参数：替换的元素
    var myFish=["angle","clown"，"mandarin","STURGEON"];
    
    myFish.splice（2,1）；
    
    //增加元素
    myFish.splice(2，0，"刘备");
    
    //["angle","clown"，"刘备","STURGEON"];
```

#### 3.JS兼容处理

##### 1.window.event
   - ie：有window.event对象
   - ff：没有window.event对象，可以通过函数的参数传递event对象。如onclick=clickHandler(event) 
    
   - 解决办法：
   - var event = event || window.event;
##### 2.鼠标当前坐标
   - ie：event.x和event.y
    
   - ff：event.pageX和event.pageY 
    
   -解决办法：采用通用属性：event.clientX和event.clientY属性; 
##### 3. 鼠标坐标加上滚动条滚过的距离 
- ie：event.offsetX和event.offsetY 
- ff：event.layerX和event.layerY
- 解决办法： 

```js
        <script type="text/javascript">
        function mouseDownHandler(event) { var event = event || window.event; 
        //var event = event ? event : window.event; var x = event.offsetX || event.layerX; var y = event.offsetX || event.layerY; } 
        </script> 
```
##### 4. event.srcElement
- ie：event对象有srcElement属性，但是没有target属性；

-  ff：event对象有target属性，但没有srcElement属性
- 解决办法：

使用obj = event.srcElement ? event.srcElement : event.target;

来代替ie下的event.srcElement或者ff下的event.target（注意event的兼容性）;

##### 5.event.toElement

- ie：event对象有toElement属性，但没有relatedTarget属性
- ff：event对象没有有toElement属性，但有relatedTarget属性
- 解决办法：
var target = e.relatedTarget || e.toElement; 
##### 6. 标签的x和y的坐标位置，

style.posLeft 和 style.posTop

- ie：有 
- ff：没有
- 解决办法：
用通用属性obj.offsetLeft 和 obj.offsetTop 

##### 7. 窗体的高度和宽度
- ie：document.body.offsetWidth 和 document.body.offsetHeight。注意，此时页面一定要有body标签。 
- ff：
    window.innerWidth 和 window.innerHeight，以及 document.documentElement.clientWidth 和 document.documentElement.clientHeight。 

- 解决办法：

 通用属性
 
 document.body.clientWidth 和 document.body.clientHeight；
 
##### 8. 添加事件

- ie：element.attachEvent('onclick',function)

- ff：element.addEventListener('click',function,true)
- 解决办法：
element.onclick = function.

虽然都可以使用click事件。但onclick和上面两种方法效果是不一样的。onclick只有执行一个过程，而attachEvent 和 addEventListener执行的是一个过程列表，也就是多个过程。 如：element.attachEvent('onclick',func1); element.attachEvent("onclick", func2)这样func1和func2都会被执行。 

##### 9. 标签的自定义属性
- ie：如果给标签div1定义了一个属性value，可以div1.value 和 div1["value"]取得该值
- ff：不能用div1.value 和div1["value"]
- 解决办法：
div1.getAttribute('value') 

##### 10. document.form.item
- ie：现有问题，document.formName.item("itemName") 这样的语句，不能在 ff 下运行
- ff：不支持 
- 解决办法： document.formName.elements["elementName"] 
##### 10. 集合/数组类对象问题

- ie：有许多集合类对象取用时用() 
- ff：不能这样取用 
- 解决办法：
改用[]作为下标运算。

如：

document.forms("formName") 

改为 document.forms["formName"]。

document.getElementsByName("inputName")(1) 

改为 document.getElementsByName("inputName")[1] 

##### 11. html对象的id作为对象名的问题

- ie：html对象的id可以作为document的下属变量名直接使用
- ff：需要用getElementById()方法 
- 解决办法：
- 用getElementById('idName')代替idName作为对象变量使用 
##### 12. 用idName字符串取得对象的问题
- ie：利用eval(idName)可以取得 id 为 idName 的html对象。
- ff：不支持
- 解决办法：getElementById(idName) 代替 eval(idName) 
##### 13. 变量名与某 html 对象 id 相同的问题
- ie：因为html对象id 在ie中直接调用，所以变量名不能和id相同
- ff：可以使用变量名和id相同
- 解决办法，
- 声明变量时一律加上 var ，以避免歧义(最好id和变量名不要相同)。 
##### 14. document.getElementsByName() 和 document.all[name]
- ie：getElementsByName()、document.all[name] 均不能用来取得 div 元素
- ff：可以兼容document.all， 但会生成一条警告。
- 解决办法：
    - 可以用getElementById() 或者 getElementByTagName()来代替 
##### 15. input.type属性问题

- ie：input.type属性为只读
- ff：input.type属性为读写 
##### 16. window.location.href
- ie：（ff2.0以下），可以使用window.location 或 window.location.href ; ff 1.5下只能使用window.location
- 解决办法：
    - 使用window.location 来代替 window.location.href 
##### 17. 模态和非模态窗口问题
- ie：可以通过 showModalDialog 和 showModelessDialog 打开模态和非模态窗口 
- FF：不支持
- 解决办法：
    - 直接使用window.open(pageURL, name, parameters)
    - 方式打开新窗口，如果需要将子窗口中的参数传递回父窗口，可以在子窗口中使用window.opener来访问父窗口。 
    - 如：var parWin = window.opener; parWin.document.getElementById('title').value = 'My Title'; 
##### 18. body对象
- IE：body必须在body标签被浏览器完全读入后才存在
- FF：body在body标签没有被浏览器完全读入之前就存在 
- 解决方法:一切在body上插入节点的动作，全部在onload后进行
##### 19. 事件委托方法
- IE：document.body.onload = init;
- FF：document.body.onload = init();
- 解决办法：

统一使用 document.body.onload = new Function('init()'); 

或者 

docuement.body.onload = function(){/* 这里是代码 */} 

##### 20. 父元素的区别
- IE：obj.parentElement; 
- FF ：obj.parentNode
- 解决办法：因为FF与IE都支持dom，所以可以都使用obj.parentNode
##### 21.innerText
- 在IE中能正常工作，
- 但是innerText在FF中却不行. 
- 解决方法:需用textContent 

##### 22. F
F中设置HTML标签的style时，所有位置性和字体尺寸的值必须后跟px。这个IE也是支持的 
##### 23. 父节点、子节点和删除节点
- IE：parentElement、parement.children，element.romoveNode(true)。
- FF：parentNode、parentNode.childNodes，node.parentNode.removeChild(node)。

##### 24.关于frame
- IE 中可以用window.testFrame 取得该frame，
- FF中不行
- 解决方法
```js
window.top.document.getElementById("testFrame").src = 'xx.html'
window.top.frameName.location = 'xx.html'
```
注意:HTML5 不支持 <frame> 标签。

##### 25.取得元素的属性

在FF中，自己定义的属性必须 getAttribute() 取得

##### 26.FF中没有 parentElement，parement.children 而用 parentNode，parentNode.childNodes
- 问题：childNodes 的下标的含义在IE和FF中不同，FF的 childNodes 中会插入空白文本节点

- 解决方法：可以通过 node.getElementsByTagName() 来回避这个问题
问题：当html中节点缺失时，IE和FF对 parentNode 的解释不同，例如：

```html
        <form>  
            <table>  
                <input type="text"/>  
            </table>  
 </form>  
```
- FF中 input.parentNode 的值为form，
- 而IE中 input.parentNode 的值为空节点
- 问题：FF中节点自己没有 removeNode 方法
- 解决方法：必须使用如下方法 node.parentNode.removeChild(node)

##### 27.const问题

- 问题:
在IE中不能使用const关键字
- 解决方法:以var 代替
##### 28.nodeName与tagName问题
- 问题:在FF中，所有节点均有nodeName值，但textNode没有tagName值，
- 在IE中，nodeName的使用有问题
- 解决方法:使用tagName，但应检测其是否为空

##### 28.获取元素计算后的样式
```js
    //参数1:元素，获取谁的样式
    
    //参数2:伪元素，固定为null
    - window.getComputedStyle(box,null);IE11以下不支持
    - box.currentStyle;IE8以上支持
    - 解决方法
```
第一种
```js
function getStyle(element,attr){
    var result=ull;//定义一个空对象
    if("getComputedStyle" in window){
        result=window.getComputedStyle(element,null)
    }else{
        result=element.currentStyle;
        return result[attr];
    }
}
getStyle(box,"width");//调用
```
第二种
```js
function getStyle(element){
    if("getComputedStyle" in window){
        return window.getComputedStyle(element,null);
    }else{
        return element.currentStyle;
    }
}
getStyle(box).width;//调用
```
##### 29.元素属性
- IE下input.type属性为只读，
- 但是FF下可以修改
- 解决办法：不能修改input.type的属性，如果必须要修改，可以先隐藏原来的input，然后再同样的位置再插入一个新的input元素。

##### 30.调用子框架或者其他框架中的元素的问题
- 在IE中，可以用如下方法来取得子元素的值,document.getElementByid

##### 31.eval() 函数
eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。

#### 4.数组对象分组
```js
function getGroupbyId(arr,name){
    var map = {},
    dest = [];
    for(var i = 0; i < arr.length; i++){
        var ai = arr[i];
        if(!map[ai.name]){
            dest.push({
                name: ai.name,
                data: [ai]
            });
            map[ai.id] = ai;
        }else{
            for(var j = 0; j < dest.length; j++){
                var dj = dest[j];
                if(dj.name == ai.name){
                    dj.data.push(ai);
                    break;
                }
            }
        }
    }
    return dest;
 
}
```
#### 5.JS中使document.defaultView.getComputedStyle()、currentStyle()方法获取CSS属性值
##### 1.在对网页进行调试的过程中，经常会用到js来获取元素的CSS样式，方法有很多很多，现在仅把我经常用的方法总结如：

- obj.style：这个方法只能JS只能获取写在html标签中的写在style属性中的值（style=”…”），而无法获取定义在\<style type="text/css">里面的属性。

```html
<html xmlns=”http://www.w3.org/1999/xhtml“> 
<head> 
<meta http-equiv=”Content-Type” content=”text/html; charset=utf-8″ /> 
<title>JS获取CSS属性值</title> 
<style type=”text/css”> 
<!– 
.ss{color:#cdcdcd;} 
–> 
</style> 
</head> 

<body> 
<div id=”css88″ class=”ss” style=”width:200px; height:200px; background:#333333″>JS获取CSS属性值</div> 
<script type=”text/javascript”> 
alert(document.getElementById(“css88″).style.width);//200px 
alert(document.getElementById(“css88″).style.color);//空白 
</script> 
</body> 
</html>
```

##### 2.currentStyle属性和getComputedStyle属性不能设置属性,只能获取
- currentStyle:该属性只兼容IE,不兼容火狐和谷歌
- 写法:ele.currentStyle["attr"]或者ele.currentStyle.attr;

```js
var myDiv = document.getElementById("myDiv"); 
var computedStyle = myDiv.currentStyle; 
alert(computedStyle.backgroundColor); //"red" 
alert(computedStyle.width); //"100px" 
alert(computedStyle.height); //"200px" 
alert(computedStyle.border); // IE9及以上会打印出来为空  IE8及以下是undefined
```

##### 3.getComputedStyle:该属性是兼容火狐谷歌,不兼容IE
  - 写法:window.getComputedStyle(ele,null)[attr]获取是window.getComputedStyle(ele,null).attr

```html
  <!DOCTYPE html>
<html>
<head>
<title>计算元素样式</title>
<style>
#myDiv {
background-color:blue;
width:100px;
height:200px;
}
</style>
</head>
<body>
<div id ="myDiv" style="background-color:red; border:1px solid black"></div>
<script>
var myDiv = document.getElementById("myDiv");
var computedStyle = document.defaultView.getComputedStyle(myDiv, null);
alert(computedStyle.backgroundColor); //"red"
alert(computedStyle.width); //"100px"
alert(computedStyle.height); //"200px"
alert(computedStyle.border); //在某些浏览器中是“1px solid black”
</script>
</body>
</html>
```

#### 6.数据按字母排序
- String.fromCharCode()根据指定的 Unicode 编码中的序号值来返回一个字符串。
- 语法:String.fromCharCode(num1, ..., numN) ,
num1, ..., numN:一组序列数字，表示 Unicode 值。
- 由于 fromCharCode 是 String 的静态方法，所以应该像这样使用：String.fromCharCode()，而不是作为你创建的 String 对象的方法。

```js
   //将获取的数据按照A-Z字母开头排序
   //65-90 是A-Z在Unicode十进制 对应的数字

        sortgroupcity(){
            let sortobj = {};
            for (let i = 65; i <= 90; i++) {
                if (this.groupcity[String.fromCharCode(i)]) {
                    sortobj[String.fromCharCode(i)] = this.groupcity[String.fromCharCode(i)];
                }
            }
            return sortobj
        }
```

#### 7.按Enter键后Form表单自动提交的问题

```html
<form onsubmit="return false">
    <input type="text" name="test"/>
</form>
//form表单添加  onsubmit="return false"
```
#### 8.软键盘弹出收起

```js
   window.onload = function () {
            $(document).on('focusin', function () {
                console.log(123);
                　 　//软键盘弹出的事件处理
                $(".consultation-btn").stop(true).fadeOut(1000);
                });
                $(document).on('focusout', function () {
                　　 //软键盘收起的事件处理
                $(".consultation-btn").stop(true).fadeIn(1000);
            });
```

#### 9.浅析encodeURI,encodeURIComponent,decodeURI,decodeURIComponent
- Global(所有在全局作用域中定义的属性和函数，都是Global的属性)对象的encodeURI(),encodeURIComponent()方法可以对URI（通用资源标识符）进行编码，以便发送给浏览器。
- 有效的URI不能包含某些字符：例如空格。这2个URI编码方法就可以对URI进行编码，用特殊的UTF8编码替换所有无效的字符，从而让浏览器能够接受。
##### 1.encodeURI(),encodeURIComponent()

先看个demo例子：

```js
var uri = 'https://www.baidu.com/s?ie=utf-16&word=hello #index.html';

encodeURI(uri)      //https://www.baidu.com/s?ie=utf-16&word=hello%20#index.html

encodeURIComponent(uri) //https%3A%2F%2Fwww.baidu.com%2Fs%3Fie%3Dutf-16%26word%3Dhello%20%23index.html
```
从上面的例子，可以看出：

- encodeURI()编码后的结果是：空格被替换成了%20，除了空格之外的任何字符都没有改变； 
- encodeURIComponent()则是将所有非字母数字字符替换成对应编码。
- encodeURIComponent()可以对整个URI进行使用，而encodeURI()只适用于对附加URI后面的字符串使用。
- 所以一般来说，我们使用更多的的是encodeURI()，因为我们更需要对查询字符串进行编码，而不是整个URI
##### 2.decodeURI(),decodeURIComponent()

这两个方法与encodeURI(),encodeURIComponent()对应，其中decodeURI()只能对使用encodeURI()替换的字符进行解码，decodeURIComponent()能对使用encodeURIComponent()替换的字符进行解码

```js
var uri = 'https://www.baidu.com/s?ie=utf-16&word=hello%20%24#index.html';

decodeURI(uri)      //https://www.baidu.com/s?ie=utf-16&word=hello %24#index.html

decodeURIComponent(uri) //https://www.baidu.com/s?ie=utf-16&word=hello $#index.html

```
- 因为uri中有编码值%20，%24，decodeURI只可以把%20转化为空格，不会对%24仅从任何处理，因为%24表示$符号，$符号不是使用encodeURI替换的。
- 而decodeURIComponent可以解释任何特殊字符的编码。
- 我们可以使用decodeURIComponent将URL Search 中的参数转化为对象，以便我们使用：

```js
var str = 'https://www.sogou.com/sie?ie=utf8&query=%E5%91%B5%E5%91%B5&pid=AQKo5-0000';

var query = str.split('?')[1];

var result = {};

query.split("&").forEach(function(part) {
  var item = part.split("=");
  result[item[0]] = decodeURIComponent(item[1]);
});

console.log(result);

//结果：{ie: "utf8", query: "呵呵", pid: "AQKo5-0000"}

```

##### 3.escape unescape
- ECMAScript v3 已从标准中删除了 escape unescape函数，并反对使用它，因此应该用 decodeURI() 和 decodeURIComponent() 取而代之。
- URI方法能编码素所有Unicode字符，而 escape unescape只能正确编码ASCLL字符，可以看下面的demo，编码结果有点不伦不类，不便于使用：

```js
var str = 'https://www.baidu.com/s?tn=mswin_oem_dg&ie=utf-16&word=hello';
escape(str)     //https%3A//www.baidu.com/s%3Ftn%3Dmswin_oem_dg%26ie%3Dutf-16%26word%3Dhello

```
#### 10.module.exports,exports,export和export default,import与require区别与联系
##### 1.区别
- module.exports和exports是属于CommonJS模块规范！
- export和export default是属于ES6语法
- 同样import和require分别属于ES6和CommonJS！
##### 2.联系
- module.exports导出对应require导入
- export导出对应import导入
##### 3.module.exports和exports的区别与联系
Node应用由模块组成，采用CommonJS模块规范。

根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。

CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。

```js
var x = 5;
var addX = function (value) {
  return value + x;
};
module.exports.x = x;
module.exports.addX = addX;
```
上面代码通过module.exports输出变量x和函数addX。

require方法用于加载模块。

```js
var example = require('./example.js');

console.log(example.x); // 5
console.log(example.addX(1)); // 6

```

看了刚刚这段commonjs规范上面的介绍可以知道以下区别与联系：

 **其实exports变量是指向module.exports，加载模块实际是加载该模块的module.exports。** 这等同在每个模块头部，有一行这样的命令。

```js
 var exports = module.exports;
```

于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。如:

```js
exports.hello = function() {
  return 'hello';
};

module.exports = 'Hello world';
```
##### 4.export和export default的区别与联系
模块功能主要由：export和import构成。export导出模块的对外接口，import命令导入其他模块暴露的接口。

export其实和export default就是写法上面有点差别，一个是导出一个个单独接口，一个是默认导出一个整体接口。使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。这里就有一个简单写法不用去知道有哪些具体的暴露接口名，就用export default命令，为模块指定默认输出。

export可以这样写

```js
// testA.js
var f = 'Miel';
var name = 'Jack';
var data= 1988;

export {f, name, data};
```
使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。

```js
// main.js
import {f, name, data} from './testA';

export default可以这样写

// export-default.js
export default function () {
  console.log('foo');
}
// 或者写成

function foo() {
  console.log('foo');
}
export default foo;
// import-default.js
import customName from './export-default';
customName(); // 'foo'
```

下面比较一下export default和export 输出。

```js
// 第一组
export default function car() { // 输出
  // ...
}

import car from 'car'; // 输入

// 第二组
export function car2() { // 输出
  // ...
};

import {car2} from 'car2'; // 输入
```

可以看到第一组是使用export default，import语句不需要使用大括号；第二组使用export，对应的import语句需要使用大括号，一个模块只能有一个默认输出，所以export default只能使用一次。