##   Vue

### 1.概念：
- ####  1 框架和库的区别，本质：控制反转，也就是谁起到主导作用
    - #####      库，其实就是一些函数的集合，是我们在需要某个功能的时候，主动调用库中的某个方法
    - #####    框架，规定了一套编程方式，整个流程已经规定好了，我们只需要将自己的代码，放到合适的位置去（比如：vue中的数据必须放到data中），那么，框架会在合适的实际来调用我们的代码
- #### 2 MVC 和 MVVM
    - #####  它们都实现了 职责分离，将不同的功能，放到不同的块中
        - #####  M： model 数据模型（用来实现数据的增删改查）
        - #####  V： view 视图，也就是页面
        - #####  C： controller 控制器，是M和V之间的桥梁
    - #####    基本运行流程：
    - ##### 用户通过 View 进行了某个操作 ---> 控制器，处理这个操作 ---> 将数据交给Model，并完成数据的存储 ---> 将数据操作的结果返回给 控制器 ---> 控制器将结果交给 View，展示给用户
- ####  MVVM
    - #####  M： model 数据模型（用来实现数据的增删改查）
    - #####  V： view 视图，也就是页面
    - #####  VM：视图模型（ViewModel），特点：实现了数据的双向绑定
- #### 数据双向绑定的定义：
    - ##### 1 Model -> View：进入页面，将数据展示到对应的指令或表达式中去
    - ##### 2 View -> Model：如果用户通过视图对数据进行操作，那么，vue又会将这个操作同步到数据模型中

- ##### Vue中的双向数据绑定原理：
    - ##### 利用ES5中的 Object.defineProperty() 方法来实现

    - ##### Object.defineProperty() 方法，可以用来给对象添加属性
        
        - ##### 第一个参数表示：给哪个对象添加属性
        - ##### 第二个参数表示：要添加的属性名称
        - ##### 第三个参数表示：对当前要添加属性的描述对象
```
        var data = {}
        
            Object.defineProperty(data, 'msg', {
              get: function () {
                console.log('get 执行了');
                // return '111'
                return this._msg
              },
        
              set: function (val) {
                // this 指的是 data对象
                console.log(this);
                // val 表示设置给当前属性的值
                console.log('set 执行了');
        
                this._msg = val
              }
            })
    
            // 读取属性：  此时，上面配置好的get函数就会执行
            // 访问 对象data中msg的值 是由：get函数的返回值决定的
            // console.log(data.msg)
            // 设置属性：  此时，上面配置好的set函数就会执行
            data.msg = 'abc'
        
            console.log(data.msg); 
```
  - ##### 可以对添加到对象中的属性，添加修饰，而双向绑定的原理利用了：getter / setter
- ##### vue 执行的过程（双向数据绑定的原理解析）：
    - #####  1 根据传入的 el 配置项，找到页面中需要被Vue管理的内容区域
    - #####  2 遍历所有的后代元素，收集出现的所有指令（v-model）和表达式（{{}}）
    - #####  3 遍历传入 data 中的数据，分别通过 Object.defineProperty() 实现每个数据的get/set
    - #####  4 每个数据的get/和set中，分别与页面中使用该数据的指令和表达式对应起来
    - #####  5 将来当数据改变的时候，通过 设定好的set，将数据的变化同步到页面中


### 2.语法
- Vue中data对象中用来设置数据，
- methods 用于为视图提供方法，比如：事件处理程序
- vue中的实例对象前加$，全局对象不需要加
#### 指令

#####    v-model 

    <!-- {{}} 在vue中叫：mustache语法，插值表达式 -->

- #####  写Vue可能会遇到的错误：
    - #####  1 注意：Vue 是以大写字母开头的，它是一个构造函数！！！
    - #####  2 注意：在 Vue 中，HTML属性值无法使用 {{}}！！！
    - #####  3 开发期间一定要使用未压缩版的Vue（开发版）
    - #####  注意：mustache中不能出现语句，比如：if () {}  for(var i =0 ...) {} / var num = 1

- #####    v-model：只能用在表单元素中，注意：不同的表达元素，v-model的表现可能会有所不同。比如：v-model操作文本框的value属性，而复选框 v-model 就是操作其选中状态了~

```js
    <input type="text"    v-model="msg">
   <input type="checkbox" v-model="isChecked">
  
  // 通过 vm.msg 可以直接访问到data中的数据
    // 并且，修改 vm.msg = '修改' 那么视图中对应的DOM元素，也会自动发生改变！！！
    // 除了使用 vm.msg 可以直接访问到data中的数据以外，还可以通过 vm.$data.msg 获取到
    // 注意：不要使用 $作为自定义属性或方法的命名开头，否则，会与Vue中提供的内置方法或属性冲突

    var vm = new Vue({
      el: '#app',
      data: {
        msg: 'morenzhi',
        isChecked: true
      }
    })



```

- ##### v-model 可以实现数据的双向绑定，两个方向：

    - #####  1 数据 -> 视图，数据的改变会影响页面DOM元素的内容改变
      
      - #####  2 视图 -> 数据，DOM元素内容的改变也会引起数据的变化
      

---
##### v-text
- #####    v-text 用来设置当前元素的文本内容，相当于DOM对象的 innerText或textContent -->
    注意：会覆盖掉元素中的默认内容 

#####  跨站点脚本攻击： http://qingbob.com/Excess-XSS/ 
##### 注意：不要使用 v-html 展示用户输入的内容！！！ 
---
##### v-bind
- #####    通过v-bind为HTML元素绑定属性，使用data中提供的数据
    ```
    <h1 v-bind:title="msg">鼠标，你过来！</h1>
    <img v-bind:src="imgSrc" alt="">

    <!-- 因为 v-bind: 这种使用方式很繁琐，所以，vue提供了一个简化语法 :title -->
    <a :href="itcast">传智-大前端</a>
        
    <script>
    var vm = new Vue({
      el: '#app',
      data: {
        msg: '鼠标放上来了',
        itcast: 'http://web.baidu.cn',
        imgSrc: './img/1.jpg'
      }
    })
  </script>

    ```
---
##### v-on:click 用来绑定单击事件
- ######     v-on: 是绑定事件的固定前缀，click表示要绑定的事件名称,
    - ###### 比如，要绑定鼠标移上来的事件： v-on:mouseenter="
    - ###### 事件修饰符  给组件绑定原始事件 需要添加.native
```      
    <button v-on:click="fn" v-on:mouseenter="fn" v-on:mouseleave="fn">{{ msg }}
    </button>

    //绑定事件的简化语法：
    <button @click="change">简化绑定事件</button>
    //给组件绑定原生事件 需要添加.native
    <router-link @click.native="goPage()"></router-link>
```
- 原生事件就类似于你直接用$element.addEventListener(click, callback);
绑定事件。
- router-link的作用是单纯的路由跳转，会阻止click事件，只用click不用native,事件是不会触发的。
而a标签不会阻止。
```
      <div class="cls" @click="foo2">
          <!-- .stop 是事件修饰符，用来阻止事件冒泡 -->
          <button @click.self="foo1">事件冒泡了吗？？？</button>
    
          <!-- <button>事件冒泡了吗？？？</button> -->
        </div>
---
##### v-for

```
    <div id="app">
    <ul>
      <!-- item 表示数组中的每一项 -->
      <li v-for="item in list" :key="item.id">
        姓名：{{ item.name }} 年龄：{{ item.age }}
      </li>
    </ul>

    <!-- 此时的v表示：数组中的每一项值 -->
    <!-- index 表示：当前项的索引号 -->
    <p v-for="(v, index) in list">索引号：{{ index }} 姓名：{{ v.name }} 年龄：{{ v.age }}</p>

    <!-- 注意：val表示当前对象中每个属性的值 -->
    <!-- key 表示：当前项的键 -->
    <h3 v-for="(val, key, index) in obj">{{ key }} --- {{ val }} --- {{ index }}</h3>

    <!-- val 表示从 1-8 之间的数值 -->
    <span v-for="val in 8">{{ val }}</span>
  </div>
  <script src="./vue.js"></script>
  <script>
    // for(var k in list) {}
    var vm = new Vue({
      el: '#app',
      data: {
        list: [
          { id: 1, name: 'jack', age: 19 },
          { id: 2, name: 'rose', age: 18 },
          { id: 3, name: 'jerry', age: 8}
        ],

        obj: {
          name: 'tom',
          age: 9,
          gender: 'male'
        }
      }
    })
  </script>
```
---

##### v-if
- ###### 根据表达式的值得真假跳转，用来控制元素的展示和隐藏，如果没有展示，那么结构也不会出现在HTML中
##### v-else
- ##### v-else与v-if是一个组合，中间不允许出现其他元素；他们同时只有一个才能==新建并展示==
```
<h1 v-if="ok">Yes</h1>
<h1 v-else>No</h1> 
```
##### v-else-if
- ###### 表示 v-if 的 “else if 块”。可以链式调用

```
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>

```

##### v-show
- ###### v-show:用来控制元素的展示和隐藏，是通过css的display属性控制展示和隐藏
    - 如果需要进行频繁的展示和隐藏，此时，推荐使用:v-show
    - 因为v-if会删除以及新建DOM元素，这个操作很消耗性能
```
<h1 v-show="ok">Hello!</h1>
```
---
##### v-pre/v-once 提升性能
- ###### v-pre 用来跳过我们指定v-pre所在的元素内容，不再解析这段内容中的指令和表达式，从而提高渲染的性能

```
<span v-pre>{{ this will not be compiled }}</span>
```

- ######  v-once:表示内部的元素只会被vue渲染一次

---

##### v-cloak
- ##### 页面中使用{{}}的时候，经理了又{{}}-->具体内容，会造成页面‘闪烁’，
- 解决:通过添加v-cloak指令，配合 [v-cloak] { display: none } 一起用时，便面了页面闪烁
- 原理:Vue会在编译页面结束以后，将页面中所有的v-cloak指令，从页面中移除

- 示例：
```
[v-cloak] {
  display: none;
}
<div v-cloak>
  {{ message }}
</div>
```
###### 不会显示，直到编译结束。
---

#### 样式操作
```
        <div id="app">
        <!-- <h1 class="pink green">内容</h1> -->
    
        <!-- :class 指令的值是一个对象，对象的键表示要添加的类的名称，对象的值是一个布尔值，如果为 true 表示添加这个类，否则，不添加这个类 -->
        <h1 class="fz" v-bind:class="{ pink: true, green: true }">这是一段内容</h1>
    
        <!-- 一定要能够区分 带引号 与 不带引号 的区别，也就是 'fz' 与 greenStr 的区别 -->
        <!-- greenStr 代表的是 data 中的数据 -->
        <!-- 'fz' 表示一个字符串 -->
        <p :class="['pink', 'fz', greenStr]">class 值为数组的使用方式</p>
      </div>
      <script src="./vue.js"></script>
      <script>
        var vm = new Vue({
          el: '#app',
          data: {
            greenStr: 'green'
          }
        })
      </script>
```
---

    // 指令：
    // 1 v-model ----多----
    // 2 v-text
    // 3 v-html
    // 4 v-bind:title / :title ----多----
    // 5 v-on:click / @click ----多----
    // 6 v-for  ----多----
    // 7 v-bind:class / :class

##### 注意：

  - #####  1 一定是现在data中声明数据，然后，再在页面中使用
  - #####  2 动态添加到data中的数据，默认是非响应式的！！！也就是说：修改了数据的值以后，不会自动同步到视图中
  - #####  3 如果需要动态添加数据到data中，并且还像让其称为响应式数据：
  
######    1 Vue.set(对象, 属性名称, 属性的值) ---> 适用于添加单个属性
      // 第一个参数：表示要给哪个对象添加响应式属性
      // 第二个参数：表示要添加的属性名称
      // 第三个参数：表示属性的值
      // Vue.set(obj.stu, 'age', 19)

######      2 Object.assign() 方法，来动态添加多个属性
```
    // 第一个参数：是一个空对象
      // 作用：除了第一个参数以外，后面所有参数都是对象，会把后面每个对象的属性添加到第一个参数中，如果有相同的属性，以后面的值为准（也就是：后面会覆盖前面的值）
      vm.stu = Object.assign({}, vm.stu, { name: 'rose', age: 30, gender: 'male' })
    }, 3000)
```
---
#### Vue数据更新的方式:
- ##### 只要有数据发生改变，那么页面中所有的质量或表达式都会重新计算一次，只有当数据发生改变了，那么这个数据对应的指令或表达式才会被重新渲染
- ##### 如果发生这个值没有改变，那么不会更新页面；如果数据发生了改变，那么只会把这个数据对应页面的内容更新

- ##### 对于字符串的indexOf()方法来说，任何字符串.indexOf('')>-1
- ---

### 3.过滤器filter
#### 作用:
- ##### 文本格式化数据，也就是:将数据按照我们指定的一种格式输出
- ##### 过滤器可以用在两个地方:{{}}和v-bind表达式

#### 两种过滤器
- ##### 1 全局过滤器: 通过全局方式创建的过滤器，所有的实例中都可以使用，对于全局过滤器来说，需要先创建过滤器，然后在市里中使用
    - ##### 说明:全局组件在所有的Vue实例中都可以使用
    - ##### 注意:先注册组件，再初始化根实例
    - ##### 注意:组件中的data必须是函数
        - ###### 第一个参数:表示过滤器名称
        - ###### 第二个参数:表示传递给过滤器的格式
        - ######  ==过滤器的内容是由过滤器的返回值决定的==
        
```javascript
    // 1.注册全局组件

  
  
        Vue.filter('f2', function (input, format = '-六六六-') {
          return input.replace(/留/g, format)
        })

  
  // 2.使用:以自定义元素的方式
  
    <div id="app1">
        <p>{{ '下雨天留客天留我不留' | f2 }}
        </p>
      </div>
      
```

- ##### 2 局部过滤器: 属于某一个实例内部, 只能在这个过滤器中使用
 #### 使用过滤器: 
- ##### 通过 管道符号 | 竖线 来使用

```
      <p>{{ '下雨天留客天留我不留' | f1 }}</p>
<p>{{ '下雨天留客天留我不留' | f1(666, 777) }}</p>
    var vm = new Vue({
          el: '#app',
          data: { },
          // 通过 filters 配置项, 来创建过滤器
          // 一个过滤器就是一个函数
          // 过滤器的内容是由 过滤器函数的返回值决定的
          filters: {
            // 第一个参数: 表示要过滤的内容
            // 第二个参数: 表示传递给过滤器的格式
            // 实际上, 除了第一个参数以外, 后面所有的参数都是 过滤器 的格式化参数
            // format = '-六六六-' 表示 ES6中参数的默认值, 作用相当于 format = format || '-六六六-'
            // 也就是: 如果传入了参数, 就以传入的参数为准; 否则, 就使用 默认值
            f1: function (input, format = '-六六六-', format1) {
              // return '返回值'
              console.log(input, format, format1);
    
              // 处理参数默认值
              // format = format || '-六六六-'
    
              // return input.replace(/留/g, '-- LIU --')
              return input.replace(/留/g, format)
            }
          }
        })

```

### 4.键值修饰符
- #### 说明:在监听键盘事件时，Vue允许为"v-on"在监听键盘事件时添加关键修饰符
- #### 全部的按键别名：
    .enter
    .tab
    .delete (捕获“删除”和“退格”键)
    .esc
    .space
    .up
    .down
    .left
    .right
- ##### 可以通过全局 config.keyCodes 对象自定义按键修饰符别名：

        //可以使用`v-on:keyup.f1`
        Vue.config.keyCodes.f1 = 112
        
- ##### 其他：修饰键（.ctrl等）、鼠标按键修饰符（.left等）
- ##### 自动匹配按键修饰符
    - ###### 2.5.0 新增
    - ###### 你也可直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符：
    
```    
    <input @keyup.page-down="onPageDown">
    
    //在上面的例子中，处理函数在$event.key === 'PageDown' 时被调用。
```
- #### 系统修饰键

- 2.1.0 新增
- ##### 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。
    .ctrl
    .alt
    .shift
    .meta
- #### 注意：
    - ##### 在 Mac 系统键盘上，meta 对应 command 键 (⌘)。
    - ##### 在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。
    -  ##### 在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。
    -  ##### 在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。
- #### .exact 修饰符
- 2.5.0 新增
- ##### .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。
```
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button @click.ctrl="onClick">A</button>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
<button @click.exact="onClick">A</button>
```

### 5.监视数据变化 - watch
- ##### 概述:watch是一个对象，键是需要观察的表达式，值是对应回调函数
- ##### 作用:当表达式的值发生变化后，会调用对应的回调函数完成相应的监事操作
- ##### 通过watch配置项，来监视数据变化,只能监视data中的数据，要监视的数据，作为watch的属性
```
    var vm= new Vue({
        el:"#app",
        data:{
          userName: '',
        isError: false,

        stu: {
          age: 10,
          gender: 'male'
        }

        },
        watch:{
            userName:function(val,oldVal){
                //val 表示当前值
                //oldVal 表示旧值
            console.log("当前值为:"+val,"旧值为:"+oldVal);
            if(val.length<4||val.length>20){
              this.isError=true; 
            }else{
                this.isError=false;
            },
            stu:{
                handler:function(val,oldVal){
                    console.log("当
                    前值为:"+val,"旧值为:"+oldVal);
                },
                //如果要监视对象的改变，需要使用deep:true
                //注意:如果需要        监视对象的变化，那么，val和oldVla是相同的，指向
                同一个对象，deep:true深度监听，
                只要对象中任意一个属性变化了，那么handler就会
                执行
                deep:true
            }
            //有些情况，只需要监视某个属性的变化，而不是整个对象中所有的属性的变化
            //此时可以通过以下
            语法来实现:
            'stu.age':function(val,oldVal){
                console.log("age变化了:",val,oldVal);
            }
            //此时stu对象age属性变化了，才会执行
            这个函数
        },
        
            
        }
    })

```
---

### 6.computed计算属性
- ##### 说明:计算属性是基于他们的依赖进行缓存的，只有它的依赖生存发生改变时才会重新求值
- ##### 优势:缓存，提高Vue渲染数据的性能
- ##### 作用:当甲酸属性的依赖项发生改变了，那么，计算属性就会被重新计算
- ##### 注意:Mustache语法{{}}中不要放入太多的逻辑，否则会让模板过重、难以理解和维护
- ##### 注意:==computed中的属性不能与data中的属性同名，否则会报错==
```
var vm = new Vue({
  el: '#app',
  data: {
    firstname: 'jack',
    lastname: 'rose'
  },
  computed: {
    fullname() {
      return this.firstname + '.' + this.lastname
    }
  }
})
```
---
### 7.生命周期
- ##### 所有的Vue组件都是Vue实例，并且接受相同的选项对象即可(一些跟实力特有的选项除外)
- ##### 生命实例周期也叫做:组件生命周期，一个组件从开始到最后小王所经历的各种状态，就是一个组件的声明周期
![生命周期](_v_images/_生命周期_1514707898_1522.png)

#### 一个实例组件的生命周期有三个阶段

   - ##### 1.初始化阶段
   - ##### 2.数据更新阶段
   - ##### 3.卸载阶段
- 注意：Vue在执行过程中会自动调用生命周期钩子函数，我们只需要提供这些钩子函数即可
- 注意：钩子函数的名称都是Vue中规定好的！
#### created:发送Ajax请求  mounted:操作Dom，操作Dom时要用自定义指令
#### 钩子函数
##### 1.beforeCreate
      -       说明:在实例初始化之后，数据观测(data observer)和event/watcher事件配置之前被调用
      -       注意:此时，无法获取data中的数据、methods中的方法

##### 2. created
      -       注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据
      -       [vue实例生命周期 参考1](https://segmentfault.com/a/1190000008879966)
      -      [vue实例生命周期 参考2](https://segmentfault.com/a/1190000008010666)
      -     使用场景：发送请求获取数据

#####  3.beforeMounted
    -    说明:在挂载开始之前被调用
##### 4.mounted
    -     说明:此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作
##### 5.beforeUpdated
   -    说明:数据更新时调用，发生在虚拟DOM重新渲染和和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。
   -    注意:此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的

##### 6.updated
   - ##### 说明：组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。
##### 7.beforeDestroy
   - ##### 说明：实例销毁之前调用。在这一步，实例仍然完全可用。
   - ##### 使用场景：实例销毁之前，执行清理任务，比如：清除定时器等
##### 8.destoryed
   - ##### 说明：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

```
  <div id="app">
    <!-- 法兰克对数据六块腹肌圣安德鲁放假 -->
    <p>{{ msg }}</p>

    <button @click="change">改变数据</button>
  </div>

  <script src="./vue.js"></script>
  <script>
    // 演示 outerHTML
    // outerHTML 包含了元素自身，而innerHTML 指的值当前元素的子元素
    // var app = document.getElementById('app')
    // console.log(app.outerHTML);

    var vm = new Vue({
      el: '#app',
      data: {
        msg: '这是一个值'
      },

      methods: {
        change: function() {
          this.msg = '更新后的数据'
        }
      },

      // 如果提供了 template 选项，那么不再以 el 指定的元素作为模板进行编译
      // 而是，以tempalte的值作为模板进行编译！！！
      // template: '<h1>{{ msg }}</h1>',

      beforeCreate: function() {
        // 可以在这个钩子函数中开启页面加载的 loading 效果

        // 这是第一个钩子函数
        // 注意：在这个钩子函数中，无法获取到data中的数据
        // console.log(this.msg);
        console.warn('生命周期钩子函数：beforeCreate');
      },

      created: function() {
        // 此时，可以对data中的数据进行处理
        // 可以用来发送 ajax 请求
        console.log(this.msg);
        console.warn('生命周期钩子函数：created');
      },

      beforeMount: function() {
        // 组件将要挂载到页面中，也就是说：组件的内容还没有被挂载到页面中
        // 此时，获取不到页面中DOM元素
        console.log('beforeMount', this.$el);
        console.warn('生命周期钩子函数：beforeMount');
      },

      mounted: function() {
        // 组件已经被挂载到页面中，此时，可以进行DOM操作了
        console.log('mouted', this.$el);
        console.warn('生命周期钩子函数：mounted');
      },

      // 数据更新阶段
      beforeUpdate: function() {
        console.log('beforeUpdate', this.$el.children[0].innerText);
        console.warn('生命周期钩子函数：beforeUpdate');
      },
      updated: function() {
        console.log('updated', this.$el.children[0].innerText);
        console.warn('生命周期钩子函数：updated');
      },

      // 卸载阶段
      beforeDestroy: function () {
        console.warn('生命周期钩子函数：beforeDestroy');
      },
      destroyed: function () {
        console.warn('生命周期钩子函数：destroyed');
      },
    })

    // $mount() 方法的作用与el这个配置项的作用相同，都是来指定vue管理的边界
    // vm.$mount('#app')
  </script>  
```
- ---
### 8.Axios(类似jQ中的ajax)
- 以Promise为基础的HTTP客户端，适用于：浏览器和node.js
- 封装ajax，用来发送请求，异步获取数据

#### 使用流程
##### 1.下载 npm i axios -S 导入axios.js文件
##### 2.基本使用

```
// API使用方式：

axios.get(url[, config])
axios.post(url[, data[, config]])
axios(url[, config])
axios(config)

// 在浏览器中使用，直接引入js文件使用下面的GET/POST请求方式即可
// 1 引入 axios.js
// 2 直接调用axios提供的API发送请求
created: function () {
  axios.get(url)
    .then(function(resp) {})
}
```

###### Get请求

```
<div id="app">
    <p v-for="item in list" :key="item.id">{{ item.title }}</p>

    <input type="text" v-model="txt">
    <button @click="sendComment">发表评论</button>
  </div>
  <script src="./vue.js"></script>
  <!-- 导入 axios -->
  <script src="./node_modules/axios/dist/axios.js"></script>
  <script>
    var vm = new Vue({
      el: '#app',
      data: {
        list: [],
        txt: ''
      },

      // 在这个钩子函数中发送ajax请求，获取数据
      created() {
        // axios 发送 get 请求
        axios
          .get('http://vue.studyit.io/api/getnewslist')
          // 调用 then 方法，获取接口返回的数据
          .then(res => {
            // res 是ajax的响应结果，服务器返回的数据，在：res.data 中
            console.log(res.data);
            this.list = res.data.message
          })
      }
})

```

###### Post请求


```
  <div id="app">
    <p v-for="item in list" :key="item.id">{{ item.title }}</p>

    <input type="text" v-model="txt">
    <button @click="sendComment">发表评论</button>
  </div>

<script src="./vue.js"></script>
  <!-- 导入 axios -->
  <script src="./node_modules/axios/dist/axios.js"></script>
  <script>
    var vm = new Vue({
      el: '#app',
      data: {
        list: [],
        txt: ''
      },

      methods: {
        sendComment() {
          // CORS 跨域资源共享: http://www.ruanyifeng.com/blog/2016/04/cors.html
            //Post 请求
          axios
          // 第一个参数：接口地址
          // 第二个参数：表示发送给接口的参数
          // 注意: POST请求参数的形式, 是 "键=值&键1=值1&键2=值2" 形式
          // 如果是直接将对象作为参数发送, 那么 此时的 Content-type 为:  application/json , 那么, 浏览器会发送 预检请求
          // 如何解决 预检请求 的问题???
          // 1 使用 "键=值&键1=值1&键2=值2" 形式的参数
          // 2 通过 npm 安装 qs模块, 调用 qs.stringfy( {} ) 将对象参数转化为 "键=值"
            // .post('http://vue.studyit.io/api/postcomment/17', { content: this.txt })
            .post('http://vue.studyit.io/api/postcomment/17', 'content=' + this.txt)
            .then(res => {
              console.log(res.data);
            })
        }
      }
    })
  </script>

```

---
### 9.自定义指令
#### 全局指令
##### [vue 自定义指令用法实例](https://juejin.im/entry/58b7c5d8ac502e006cfee34a)

   - ##### 第一个参数:==表示自定义指令的名称==
   - ##### 第二个参数:表示自定义指令运行的时候，==需要执行的逻辑操作==，可以是一个函数，也可以是一个对象，对象中是指令的钩子函数
```
<div id="app">
    <!-- 使用 自定义指令，需要在 自定义指令名称前面，添加 v- 前缀 -->
    <input type="text" v-focus v-validate="">
  </div>
<script src="../vue.js"></script>
<script>
//Vue这种MVVM模式的框架不推荐开发人员直接手动操作DOM
//有些情况，还是需要操作DOM的，如果需要操作DOM,就通过Vue中的自定义指令来操作
//创建自定义指令
Vue.directive("focus",inserted(el){
    //参数:el 表示指令所在的DOM对象
    //focus()方式是原生DOM对象 方法 用于为 checkbox 赋予焦点。
    el.focus();
}

var vm=new Vue({
    el:"#app",
    data:{
        
    }
})

</script>

```

##### bind和inserted这两个钩子函数，都是进入页面就立即执行的
   - ###### 区别:inserted能获取到指令所在元素的父元素对象，bind只能获取当前元素对象,获取不到父元素
```
Vue.directive("focus",{
//bind只能对元素自身进行DOM操作，而无法对父级元素操作
    bind(el){
        console.log(el.parentNode);
    },//null
    //inserted这个钩子函数调用的时候，当前元素已经插入页面中了
    也就是说可以获取到父元素的节点
    insertted(el){
        console.log(el.parentNode);
    }
    //<div id="app">...</div>
})
```
- ##### update Dom 获取DOM元素的内容是更新前的内容；componentUpdated 获取DOM元素的内容是更新后的内容
```
// DOM重新渲染前
update(el) {
  console.log('update:', el.innerHTML);
},

// DOM重新渲染后
componentUpdated(el) {
  console.log('componentUpdated: ', el.innerHTML);
},
```

- ##### unbind:只调用一次，如果指令所在的元素，从页面中移除（消失），那么就会执行unbind钩子函数
```

    Vue.directive("focus",{
        unbind() {
        console.log('unbind');
      }

    })
```
- ###### 钩子函数参数
    - ###### el:指令所绑定的元素，可以用来直接操作DOM
    - ###### binding:一个对象，包含以下属性
        - name:指令名，不包含v-前缀
        - value:指令的绑定值，如v-my-directive="1+1"中，绑定值为2
        - oldValue:指令绑定的前一个值，仅在update和componentUpdated钩子中可用
        - expression:字符串形式的指令表达式//v-my-directive="1+1" 表达式为"1+1"
        - arg:传给指令的参数，可选
```
        // :test 需要在 .foo 之前 test就是arg参数
        
    <h1 v-focus:test.foo.bar="1 + 3">{{ msg }}</h1>
    <h1 v-focus>{{ msg }}</h1> 
```
        - modifiers:一个包含修饰符的对象
- ##### 局部指令
- ###### 想注册局部指令，组件中也接受一个 directives 的选项：
```
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
```
- --
### 10.组件
#### 1.说明
- Vue的组件是孤立的，两个组件之间是无法直接相互通讯的！！！
- 必须借助某种机制才能实现两个组件之间的通讯！！！
- 创建组件的两种方式:1.全局组件 2.局部组件
#### 2.全局组件
-  全局组件在所有的vue实例中都可以使用
-  注意:==先注册组件，再初始化根实例==
##### 1.直接vue.compontent （‘引用组件时的名称’，{组件实际的定义模板}）
```
//1.注册全局组件
Vue.component("hello",{

    template:`<p>A custom component!</p>`，
    data(){
        return {
            msg:'注意:组件的data必须是一个函数!'
        }
    }
})

//2.使用:以自定义元素的方式
<div id="app">
    <!-- 使用组件，直接将组件的名称当作标签名称 -->
    <hello></hello>
  </div>

  
```

```

<script type="text/x-template" id="tpl">
  <p>A custom component!</p>
</script>

template: '#tpl'
```
##### 2. extend
使用基础Vue构造器，创建一个"子类";参数是一个包含组件选项的对象

- 使用vue.extend({})定义全局组件，然后再通过vue.component把vue.extend， 定义的组件注册到vue全局上。
```html
<!DOCTYPE html>
<html>
  <body>
    <div id="app">
      <!-- 3. #app是Vue实例挂载的元素，应该在挂载元素范围内使用组件-->
      <my-component></my-component>
    </div>
  </body>
  <script src="js/vue.js"></script>
  <script>
  
    // 1.创建一个组件构造器
    var myComponent = Vue.extend({
      template: '<div>This is my first component!</div>'
    })
    
    // 2.注册组件，并指定组件的标签，组件的HTML标签为<my-component>
    Vue.component('my-component', myComponent)
    
    new Vue({
      el: '#app'
    });
    
  </script>
</html>

```

##### 3，vue.compontent(‘组件名称’，{template:模板id})
- 注意:组件中的data必须是函数
##### template属性的值可以是:
- 1.模板字符串
-  2.模板id
#### 3. 父组件 子组件通讯
#####  1、通过props属性来传递数据
    - ######  注意：属性的值必须在组件中通过props属性显示指定，否则，不会生效
    - ######  说明：传递过来的props属性的用法与data属性的用法相同
```
<hello msg="120"></hello>
<hello my-msg="'abc'"></hello>

<!-- js -->
<script>
  components: {
    hello: {
      // 显式创建props及其传递过来的属性
      props: ['msg', 'myMsg'],
      template: '<h1>这是 hello 组件，这是消息：{{msg}} --- {{myMsg}}</h1>'
    }
  }
</script>

```

```
<div id="app">
    <!-- 使用组件，直接将组件的名称当作标签名称 -->
    <hello money="5"></hello>
  </div>
  <script src="./vue.js"></script>

<script>

    //1.注册全局组件
    //参数1:组件名称
    //参数2:是一个配置对象，与Vue实例的配置几乎相同
    
    Vue.component("hello",{
    //template 表示组件的模板，也就是组件要展示的HTML结构
    //注意:template指定的模板，只能且必须有一个根元素!!!
    
    template: `<div>
        <h1>这是 Hello 组件 -- {{ msg }}</h1>
        <p>接受到父组件传递过来的数据：{{ money }}</p>
        <button @click="fn">单击</button>
      </div>`,
      
    //显示指定props，表示接收父组件传递给子组件的数据
    //props中的属性用法与data中的数据用法相同
    
    props:['money'],
    
    //注意:组件中的data是一个函数！！！
    data(){
        return{
            msg:"组件中的msg数据"
        }
    },
    methods:{
        fn(){
            this.msg="修改了msg的值"+this.money;
        }
    }
    })
    var vm=new Vue({
    
        el:"#app",
        data:{
            
        }
    })
</script>
```

##### 2. v-model 实现父组件传递数据给子组件
一个组件的 v-model 会使用 value prop 和 input 事件。但是诸如单选框、复选框之类的输入类型可能把 value 用作了别的目的。model 选项可以避免这样的冲突：
```
Vue.component('my-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean,
    // 这样就允许拿 `value` 这个 prop 做其它事了
    value: String
  },
  // ...
})
<my-checkbox v-model="foo" value="some value"></my-checkbox>
上述代码等价于：
<my-checkbox
  :checked="foo"
  @change="val => { foo = val }"
  value="some value">
</my-checkbox>
```

#### 4.子组件到父组件
      - #####  方式:父组件给子组件传递一个函数，由子组件调用这个函数
      - #####  说明：借助vue中的自定义事件（v-on:cunstomFn="fn"）
      - #####  $emit()：触发事件
```
 <div id="app">
    {{ msg }}
    <!-- v-on:pfn 是自定义事件，pfn这个名称是任意的 -->
    <!-- <hello v-on:pfn="parentFn"></hello> -->
    <hello @pfn="parentFn"></hello>
  </div>
  <script src="./vue.js"></script>
  <script>
    // 组件通讯： 子 -> 父
    // 原理：父组件提供方法，子组件调用方法
    //  1 由父组件提供一个方法
    //  2 将这个方法传递给子组件
    //  3 由子组件调用这个方法
    //  4 需要传递的数据作为参数

    // 在以上的过程中有两个问题：
    // 1 父组件如何将方法传递给子组件？？？
    // 2 子组件如何调用这个方法？？？

    var vm = new Vue({
      el: '#app',
      data: {
        bar: 500,
        msg: ''
      },

      methods: {
        // 父组件提供的方法，这个方法将来由子组件调用
        parentFn: function (data, data1) {
          // 参数data，就是子组件传递过来的数据
          console.log(data, data1);
          this.msg = data
        }
      },

      // 通过 components 来创建属于该实例的局部组件
      components: {
        hello: {
          template: `
            <div>
              <h1>this is Hello Component！</h1>
              <button @click="toParent">传递数据给父组件</button>
            </div>
          `,
          
          data() {
            return {
              childMsg: '这是儿子'
            }
          },
          
          // 注意：这个方法是在 hello组件内部的
          // 可以直接将子组件data中的数据，传递给父组件
          methods: {
            toParent: function () {
              // this.$emit('pfn', '子组件传递给父组件的数据')

              this.$emit('pfn', this.childMsg, '第二个数据')
            }
          }
        }
      }
    })
  </script>
</script>
```
- ####  非父子组件通讯
       - ##### 在简单的场景下，可以使用一个空的 Vue 实例作为事件总线
        - ###### $on():绑定事件
``` 
<div id="app">
    <aaa></aaa>
    <bbb></bbb>
 </div>
 <script src="./vue.js"></script> 
<script>
//事件总线
    var bus =new Vue();
//组件A发送数据给组件B  需要组件A触发事件，然后组件B再绑定事件
//触发组件 A的事件
var vm= new Vue({
    el:"#app";
    data:{
    },
//通过components 来创建属于该实例的局部组件
components:{
    aaa:{
            template:` <div>
              <h1>组件A</h1>
              <button @click="fn">传递数据给组件B</button>
            </div>
                      
                            `,
            methods:{
                    fn(){
                        //触发事件，传递数据
                        bus.$emit("bfn","组件A说:你好组件B")
                        }
                }
        }，
    
   bbb:{
            template:` <div>
                                        <hr>
              <h1>组件B:{{msg}}</h1>
  </div>
                                                  `,
               data(){
                    return{
                        msg:" ";
                        }
                },
        //在钩子函数中，绑定事件，这样以进入页面，事件就绑定好了，等待组件A触发
            created(){
                  //绑定事件，接收数据
                bus.$on("bfn",data=>{
                    this.msg=data;
                    }) 
                }
        }，


    }    
})

</script>
```
- ### 获取组件(或元素) -refs
    - ##### 说明：vm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素）
    - ##### 使用：在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取
    - ##### 注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods
    - ##### 实例:
```
<div id="app">
        <!-- 添加ref,将来就可以通过dv来获取到当前Dom对象 -->
        <div ref="dv">这是内容</div>
        <!-- 添加ref后，可以通过$refs.ho来获取到组件 -->
        <hello ref="ho"></hello>
    </div>
    <script src="../vue.js"></script>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {

            },
            components: {
                hello: {
                    template: ` <h1>hello组件</h1>`,
                    data() {
                        return {
                            msg: "hello message",
                        }
                    },
                    methods: {
                        fn() {
                            console.log("组件hello中的方法被调用了");

                        }
                    }
                }
            },
            mounted() {
                console.log(this.$refs.dv);
                // this.$refs.dv 就是一个DOM对象

                // mui('#app').方法。。。
                // 在 Vue 中配合 mui 使用：
                // mui( this.$refs.dv ).方法。。。
                this.$refs.dv.style.color = 'red';
                //直接获取创建好的组件对象
                console.log(this.$refs.ho);
                this.$refs.ho.fn();

            }
        })
    </script>
```

---
###  11. 单页应用程序
 - #####   单页Web应用(single page application，SPA)，就是只有一个Web页面的应用，加载单个HTML页面，并在用户与应用程序交互时动态更新该页面的Web应用程序。
   - ##### 优势:
        - ###### 1.减少了请求体积，加快页面响应速度，降低了对服务器的压力
        - ###### 2. 更好的用户体验，让用户在web app感受native app的流畅
   - ##### 主要技术点
          - #######       1 ajax
          - #######       2 锚点的使用（window.location.hash #）
          - #######       3 hashchange 事件
 - ##### 
http-server 包的使用：
1 全局安装 npm i -g http-server
2 需要在哪个文件夹中开启服务器，就在哪个目录中执行： http-server 即可

### 12.路由
   - ##### 安装: npm i -S vue-router
   - ##### 1.实例:
```
<div id="app">
<!-- 6.指定路由入口 触发路由 -->
<router-link to="/news/1">新闻1</router-link>
<router-link to="/news/2">新闻2</router-link>
<router-link to="/news/3">新闻3</router-link>
<!-- 5.指定路由出口 指定路由的内容展示在页面的位置-->
<router-view></router-view>
</div>
<script src="../vue.js"></script>
<!-- //1.引入vue-router -->
<script src="./node_modules/vue-router/dist/vue-router.js"></script>
<script>
//3.创建组件
var News = Vue.component("find", {
template: `<h1 @click="fn" >News组件---{{$route.params.name}}</h1>`,
methods: {
fn() {
//获取路由参数
console.log($route.params.name);

}
}
})
//2.创建路由
var router = new VueRouter({
//通过routes类配置路由规则
routes: [
//path属性用来指定路由的路径 component指定跳转的组件名称
{
path: '/news/:name',
component: News
}
]


})
var vm = new Vue({
el: '#app',
data: {

},
//4.将路由和Vue实例关联起来,路由才会生效
router

})
</script>

```
- #### 重定向
  - ##### 说明: 将/重定向到/home
```
  
var router = new VueRouter({
//通过routes来配置路由规则
routes: [{
// 如果当前路径为 /，那就跳转到 /friend 
path: "/",
redirect: "/friend"
},

{
path: "/find",
component: Find
}, {
path: "/my",
component: My
}, {
path: "/friend",
component: Friend
},
]
})

```
- ##### 2. 路由导航高亮
   - ##### 说明：当前匹配的导航链接，会自动添加router-link-exact-active router-link-active类
   - #####  通过配置项 linkActiveClass: 'now' 来修改默认的高亮类名
```
<style>
/* .router-link-exact-active,
.router-link-active */
.now {
color: hotpink;
font-size: 30px;
text-decoration: none;
}
</style>
// 2.创建路由
        var router = new VueRouter({
            routes: [{
                path: "/",
                redirect: "/friend"
            }, {
                path: "/friend",
                component: Friend
            }, {
                path: "/my",
                component: My
            }, {
                path: "/find",
                component: Find
            }],
            //修改默认高亮的a标签的类名
            //如果是配合第三方组件库来实现菜单高亮，此时，只需要将类名设置为第三方组件的类名即可
            linkActiveClass: "now"
        })
```
- #####  3.路由参数
    - #####  说明：我们经常需要把某种模式匹配到的所有路由，全都映射到同一个组件，此时，可以通过路由参数来处理
    - ##### 语法：/user/:id
 - ###### 使用：当匹配到一个路由时，参数值会被设置到 this.$route.params
   - #####  其他：可以通过 $route.query 获取到 URL 中的查询字符串（queryString） 等
``` 
    // 3 创建组件
    var News = Vue.component('find', {
      template: `<h1 @click="fn">News 组件 --- {{ $route.params.name }}</h1>`,

      methods: {
        fn() {
          // 获取路由参数
          console.log(this.$route.params.name);
        }
      }
    }) 
 // 2 创建路由
    var router = new VueRouter({
      // 通过 routes 来配置路由规则
      routes: [
        // :id 表示路由参数
        // 此时，/news/:id 就能够匹配符合这个规则的很多个哈希值了
        // /news/13
        // /news/14
        // /news/15
        // /news/abc

        // 注意：这些哈希值不能被匹配： /news、/news/ 、/news/13/info
        { path: '/news/:name', component: News }
        /* { path: '/news/13', component: News },
        { path: '/news/14', component: News },
        { path: '/news/14', component: News }, */
      ],

      // 修改默认高亮的a标签的类名
      // 如果是配合第三方组件库来实现菜单高亮，此时，只需要将类名设置为 第三方组件的类名即可
      linkActiveClass: 'now'
    }) 

```
        - ##### 查询字符串 $route.query
```
  <div id="app">
        <!-- 6.路由出口 -->
        <router-link to="/news/1?q=jack#/test">发现音乐</router-link>
        <router-link to="/news/2?q=rose#/laskdfh">我的音乐</router-link>
        <!-- 5.路由出口 决定路由在页面中显示的位置 -->
        <router-view></router-view>

    </div>
    <script src="../vue.js"></script>
    <!-- 1.引入vue-router -->
    <script src="./node_modules/vue-router/dist/vue-router.js"></script>
    <script>
        //3.创建组件
        var My = Vue.component({
                template: `<P>这是My组件，出来了吗</P>`,
            })
            //查询字符串参数的使用:不需要在路由的path显式指定，直接在router-link的to属性中使用
            //1.在router-link to="/news/11?q=jack" 中指定（也就是：?q=jack）
            //2.在模板中直接通过$route.query.q就可以获取到查询字符串的参数(jack)




        var News = Vue.component("find", {
                template: `  <div>
          新闻详情:这是{{$route.params.id}}==>{{$route.query.q}}
          <p>{{$route.hash}}</p>
        </div>
              `
            })
            // 2.创建路由
        var router = new VueRouter({
            routes: [{
                path: "/",
                redirect: "/news/1"
            }, {
                path: "/news/:id",
                component: News
            }],
            //修改默认高亮的a标签的类名
            //如果是配合第三方组件库来实现菜单高亮，此时，只需要将类名设置为第三方组件的类名即可
            linkActiveClass: "now"
        })


        var vm = new Vue({
            el: '#app',
            data: {

            },
            router
        })
    </script>
```
- #####  4.嵌套路由-子路由
   - ##### 路由是可以嵌套的，即：路由中又包含子路由
   - ###### 规则：父组件中包含 router-view，在路由规则中使用 children 配置
  
 ```
   <div id="app">
        <!-- 路由入口 -->
        <router-link to="/index">主页</router-link>
        <router-link to="/user">用户</router-link>
        <!-- 路由出口 -->
        <router-view></router-view>
    </div>
    <script src="../vue.js"></script>
    <script src="./node_modules/vue-router/dist/vue-router.js"></script>
    <script>
        var Index = {
            template: ` <div class="index">
                          <h1>这是后台管理系统首页</h1>
                          <router-link to="/index/profile">首页</router-link>
                          <router-link to="/index/shop">购物车</router-link>
                          <!-- 子路由展示在此处 -->
                          <router-view></router-view>
                    </div>`,
        }
        var User = {
            template: `<div class="user">
                <h1>这是用户管理系统首页</h1>
        <router-link to="/user/shopcity">商城</router-link>
        <router-link to="/user/person">个人中心</router-link>
        <!-- 子路由展示在此处 -->
        <router-view></router-view>
      </div>`
        }
        var Profile = {
            template: ` <div>
                        <p>籍贯</p>
                        <p>年龄</p>
                      </div>`,
        }
        var Shop = {
            template: ` <div>
                        <p>姓名</p>
                        <p>年龄</p>
                      </div>`,
        }
        var Shopcity = {
            template: `  <div>
          <p>姓名</p>
          <p>年龄</p>
          <p>职业</p>
          <p>爱好</p>
        </div>`
        };
        var Person = {
            template: `    <div>
            <p>岗位</p>
            <p>简称</p>
            <p>薪资要求</p>     
          </div>`,
        };
        var router = new VueRouter({
            routes: [{
                path: '/index',
                component: Index,
                children: [{
                    path: "profile",
                    component: Profile
                }, {
                    path: "shop",
                    component: Shop
                }]
            }, {
                path: '/user',
                component: User,
                //通过children属性，来制定路由的子路由
                children: [{
                    path: "shopcity",
                    component: Shopcity
                }, {
                    path: "person",
                    component: Person
                }]
            }]
        })
        var vm = new Vue({
            el: "#app",
            data: {
            },
            router
        })
    </script>
 ```
   
### 13.前端模块化
   npm i -S requirejs
   
####  1.模块化规范的内容：
- 1 如何定义模块
- 2 如何导出（加载）模块
####  2.如何导入一个模块？？？
     require(['./js/a.js'])
   - 1.第一个参数：表示要加载模块的路径
   - 2. 第二个参数：是一个回调函数，可以通过参数，来获取到加载模块的内容
     require(['./js/a.js'], function (test) {
     console.log(test);
   })
######  注意：require 加载模块的顺序 与 后面回调函数参数的顺序 需要保持一直！！！
```
    require(['./js/a', './js/b'], function (a, b) {
      console.log('a模块的内容：', a);
      console.log('b模块的内容：', b);
    })
```
####  3.模块化解决的问题
        - 1 命名冲突
        - 2 文件依赖（加载文件）
        - 3 模块的复用
        - 4 统一规范和开发方式
####  4.JS实现模块化的规范
        - AMD 浏览器端
          - requirejs
        - CommonJS nodejs
          - 加载模块：require()
          - 导出模块：module.exports = {} / exports = {}
        - ES6 中的 import / export
        - CMD 浏览器端
          - 玉伯（阿里前端大神） -> seajs
        - UMD 通用模块化规范，可以兼容 AMD、CommonJS、浏览器中没有模块化规范 等这些语法
#### 5.AMD
-  Asynchronous Module Definition：异步模块定义，浏览器端模块开发的规范
-  代表：require.js
-  requirejs 文档
-  特点：模块被异步加载，模块加载不影响后面语句的运行
#### 6.定义模块
   ```
         // 定义模块
        // id表示：当前模块的名称，是一个字符串
        // dependencies表示：当前模块的依赖项，是一个数组
        // factory表示：当前模块要完成的一些功能，是一个函数
        // define(id?, dependencies?, factory);
        // 定义对象模块
        define({})
        // 定义方法模块
        define(function() {
          return {}
        })
        // 定义带有依赖项的模块
        define(['js/a'], function() {})
   ```
#### 7.加载模块
##### 注意：require的第一个参数必须是数组
   
   ```
           // 参数必须是数组
        require(['a'])
        require(['a', 'js/b'], function(a, b) {
          // 使用模块a 和 模块b 中的代码
        })
   ```
   
#### 8.路径查找说明
##### requirejs 默认使用 baseUrl+paths 的路径解析方式
##### 可以使用以下方式避开此设置：

- 1 以.js结尾
- 2 以 / 开始
- 3 包含协议：https:// 或 http://

   ```
   <script src="./require.js"></script>
     <!-- 1 导入requirejs -->
  <script>
    // 只要使用 requirejs 那么就会使用以下的方式来配置路径规则: baseUrl+paths 的形式
    require.config({
      // baseUrl 用来设置查找模块的基础路径
      baseUrl: './js',
      paths: {
        // 为 template 配置一个路径, 注意: 路径后面不能带有 .js 后缀!!!
        // 配置好了 path路径后, 再次加载这个模块, 只需要导入 template 即可!!!
        // 也就是: require(['template'])
        template: 'assets/artTemplate/template-native',
        d: 'scripts/d',
        e: 'scripts/e'
      }
    })
    // 加载 a模块
    // require(['a'])
    // require(['template'])
    require(['e'])
  </script>

   ```
#### 9.配置基础路径
   
```
   require.config({
  baseUrl: './js' // 配置基础路径为：当前目录下的js目录
})
  require(['a'])    // 查找 基础路径下的 a.js

```

#### 10.简化加载模块路径
##### 说明:template.js/jquery.js 等都默认支持 AMD 规范

```
   require.config({
  baseUrl: './js',

  // 配置一次即可，直接通过路径名称（template/jquery）加载模块
  paths: {
    template: 'assets/artTemplate/template-native',
    jquery: 'assets/jquery/jquery.min'
  }
})
require(['jquery', 'template'])

```
####  11.非模块化和依赖项支持
- ##### 1 添加模块的依赖模块，保证加载顺序（deps）
- ##### 2 将非模块化模块，转化为模块化（exports）

```
 // 有些js文件, 是没有遵守模块化规范的
    // 那么, 我们无法通过 requirejs 来获取到这个js文件中的内容
    // 怎么解决这些非模块化的js文件??? (如何让非模块化 转化为 模块化)
    // 通过 shim 配置项来解决这个问题
    require.config({
      baseUrl: './js',

      paths: {
        template: 'assets/artTemplate/template-native',
        d: 'scripts/d',
        e: 'scripts/e',
        // 1 配置非模块化js文件的路径
        not: 'not'
      },

      shim: {
        // 2 在 shim 中, 通过与 paths 中相同名称的属性名 not 来配置其 exports 配置项
        not: {
          // 3 通过 exports 来指定这个模块中需要“导出”的内容
          // 通过 exports 来指定这个js文件中需要导出的内容
          // exports: 'fn'
          exports: 'num'
        }
      }
    })
   require(['e'])
   4 就像使用模块化库一样，使用非模块化的js文件就可以了
    require(['not'], function (not) {
      console.log(not);
     not()
    })
  </script>

```

#### 12.注意点
##### 如果定义模块的时候，指定了模块名称，需要使用该名称来引用模块

```
// 这个模块名称与paths中的名称相同
define('moduleA', function() {})

require.config({
  paths: {
    // 此处的模块名：moduleA
    moduleA: 'assets/demo/moduleA'
  }
})
```
#### 13.路径加载规则
##### 路径配置的优先级：
- 1 通过 config 配置规则查找
- 2 通过 data-main 指定的路径查找
- 3 以引入 requirejs 的页面所在路径为准查找

```
<!-- 
  设置data-main属性
  1 data-main属性指定的文件也会同时被加载
  2 用于指定查找其他模块的基础路径
-->
<script src="js/require.js" data-main="js/main"></script>
```

#### 14、vue单文件组件
- [vue-loader](https://vue-loader.vuejs.org/zh-cn/)
- single-file components(单文件组件)
- 后缀名：.vue，该文件需要被预编译后才能在浏览器中使用
- 注意：单文件组件依赖于两个包 vue-loader / vue-template-compiler
- 安装：npm i -D vue-loader vue-template-compiler
```
    <!-- App.vue 示例代码： -->
    <template>
      <div>
      <!--注意:必须有一个唯一的根元素-->
        <h1>VUE 单文件组件示例 -- App.vue</h1>
        <p>这是 模板内容</p>
      </div>
    </template>
    
    <script>
      // 组件中的逻辑代码
      export default {}
    </script>
    
    <style>
    /* 组件样式 */
    h1 {
      color: red;
    }
    </style>

    // webpack.config.js 配置：
    module: {
      rules: [
        {
          test: /\.vue$/,
          loader: 'vue-loader'
        }
      ]
    }

```
##### 使用单文件组件

```
/* main.js */

import Vue from 'vue'
// 导入 App 组件
import App from './App.vue'

const vm = new Vue({
  el: '#app',
  // 通过 render 方法，渲染App组件
  render: c => c(App)
})

```
###### 单文件组件使用步骤
- 1 安装：npm i -D vue-loader vue-template-compiler
- 2 在 webpack.config.js 中配置 .vue 文件的loader
  - { test: /\.vue$/, use: 'vue-loader' }
- 3 创建 App.vue 单文件组件，注意：App可以是任意名称
- 4 在 main.js 入口文件中，导入 vue 和 App.vue组件，通过 render 将组件与实例挂到一起
###### 单文件组件+路由
[vue - Vue.use](https://cn.vuejs.org/v2/api/#Vue-use)
[Vue.use 和 路由](https://cn.vuejs.org/v2/guide/plugins.html#使用插件)

```
import Vue from 'vue'
import App from './App.vue'

// ------------- vue路由配置 开始 --------------
import Home from './components/home/Home.vue'
import Login from './components/login/Login.vue'

// 1 导入 路由模块
import VueRouter from 'vue-router'
// 2 ** 调用use方法使用插件 **
Vue.use(VueRouter)
// 3 创建路由对象
const router = new VueRouter({
  routes: [
    { path: '/home', component: Home },
    { path: '/login', component: Login }
  ]
})

// ------------- vue路由配置 结束 --------------

const vm = new Vue({
  el: '#app',
  render: c => c(App),
  // 4 挂载到 vue 实例中
  router
})
```

#### 15.Mint-UI

- 基于 Vue.js 的移动端组件库
- [Mint-UI](http://mint-ui.github.io/#!/zh-cn)
##### 快速开始
- 安装：npm i -S mint-ui
```
// 安装
# Vue 1.x
npm install mint-ui@1 -S
# Vue 2.0
npm install mint-ui -S

// 1 导入 mint-ui模块
import MintUI from 'mint-ui'
// 2 导入 样式
import 'mint-ui/lib/style.css'
// 3 注册插件
Vue.use(MintUI)

// 引入全部组件
import Vue from 'vue';
import Mint from 'mint-ui';
Vue.use(Mint);

// 按需引入部分组件  不需要另外引入css文件
import { Cell, Checklist } from 'minu-ui';
Vue.component(Cell.name, Cell);
Vue.component(Checklist.name, Checklist);
```
#### 16.ElementUI
- 这是PC端的UI组件库
- 安装：npm i -S element-ui
- [饿了吗 - ElementUI](http://element.eleme.io/#/zh-CN/component/quickstart)

```
{
  "presets": [
    ["es2015", { "modules": false }], "stage-0"
  ],

  "plugins": [
    ["component", [
      {
        "libraryName": "mint-ui",
        "style": true
      },
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-default"
      }
    ]]
  ]
}
```
#### 17.配置说明 - CLI配置(脚手架)
- 快速生成项目的目录结构，比如:vue的脚手架‘vue-cli’
#### 具体
- vue init webpack exprice --------------------- 这个是那个安装vue脚手架的命令
This will install Vue 2.x version of the template. ---------------------这里说明将要创建一个vue 2.x版本的项目
For Vue 1.x use: vue init webpack#1.0 exprice
- Project name (exprice) ---------------------项目名称
- Project name exprice
? Project description (A Vue.js project) ---------------------项目描述
- Project description A Vue.js project
? Author Datura --------------------- 项目创建者
- ? Author Datura
- Vue build (Use arrow keys)
? Vue build standalone
? Install vue-router? (Y/n) --------------------- 是否安装Vue路由，也就是以后是spa（但页面应用需要的模块）
- ? Install vue-router? Yes
- ? Use ESLint to lint your code? (Y/n) n ---------------------是否启用eslint检测规则，这里个人建议选no
- ? Use ESLint to lint your code? No
- ? Setup unit tests with Karma + Mocha? (Y/n)
? Setup unit tests with Karma + Mocha? Yes
- ? Setup e2e tests with Nightwatch? (Y/n)
? Setup e2e tests with Nightwatch? Yes
vue-cli · Generated "exprice".
To get started: --------------------- 这里说明如何启动这个服务
cd exprice
npm install
npm run dev

作者：datura_lj
链接：https://www.jianshu.com/p/1626b8643676
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
#### 18.Vuex
#### 19.项目坑
##### scroll滚动警告的处理

```css
/*
  photo/List.vue 组件中使用mui scroll插件后，在Chrome浏览器中有警告提示
  参考这篇文章，查看原因：
  scroll滚动警告的处理方式参考：http://www.jianshu.com/p/baf61adc8667

  解决方案：
*/

.mui-scroll {
  touch-action: none;
}
```


```js
// vue-router 编程式导航：
// https://router.vuejs.org/zh-cn/essentials/navigation.html
showInfo(id) {
  this.$router.push('/home/photoinfo/' + id)

  // name 是路由规则中的配置的name属性
  this.$router.push({ name: 'user', params: { userId: 123 }})
}
```
##### 编程式导航的使用


```html
<template>
  <a class="mui-tab-item" href="/home" @click="goPage('/home')">
    <span class="mui-icon mui-icon-home"></span>
    <span class="mui-tab-label">首页</span>
  </a>
</template>

<script>
export default {
  methods: {
    goPage(path) {
      // console.log(this);
      // 文档：https://router.vuejs.org/zh-cn/essentials/navigation.html

      // 实现编程式导航
      // path 表示要跳转的路径，与路由规则中的path想对应
      // name 表示路由的名称，与路由规则中的name想对应
      // params 表示路由参数
      // 调用 $router.push({ path: '/home' })
      // router.push({ name: 'user', params: { userId: 123 }})
      this.$router.push({ name: 'jack' })
    }
  }
}
</script>
```
##### vue过渡效果

```html
<input type="button" value="toggle" @click="flag=!flag">
<transition
  @before-enter="beforeEnter"
  @enter="enter"
>
  <h3 v-show="flag" class="cls">Vue过渡效果</h3>
</transition>

<script>
  var vm = new Vue({
    el: '#app',
    data: {
      flag: false
    },
    methods: {
      // 入场动画之前，设置 元素的起始样式
      beforeEnter(el) {
        el.style.transition = 'all 1s ease'
        el.style.transform = 'translateY(30px)'
      },
      enter(el, done) {
        el.offsetWidth // 或者 写 el.offsetHeight
        // 为元素设置 进入完成之后的 样式
        el.style.transform = 'translateY(0px)'
        // 入场动画完成之后，立即 把 元素隐藏
        this.flag = !this.flag
      }
    }
  });
</script>
```
##### css样式只对当前模块生效

加上scoped
```
<style lang="scss" scoped>
```
##### 1、单页面web应用的优缺点或者说vue的优缺点？
- ###### 一、定义
单页 Web 应用 (single-page application 简称为 SPA) 是一种特殊的 Web 应用。它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。一旦页面加载完成了，SPA不会因为用户的操作而进行页面的重新加载或跳转。取而代之的是利用 JavaScript 动态的变换HTML的内容，从而实现UI与用户的交互。由于避免了页面的重新加载，SPA 可以提供较为流畅的用户体验。
- ###### 二、优缺点
单页Web程序的出现是富客户端发展的必然结果，但是该技术也是有些局限性，所以采用之前需要了解清楚它的优缺点。
- 1、优点：
1).良好的交互体验
用户不需要重新刷新页面，获取数据也是通过Ajax异步获取，页面显示流畅。
2).良好的前后端工作分离模式
单页Web应用可以和RESTful规约一起使用，通过REST API提供接口数据，并使用Ajax异步获取，这样有助于分离客户端和服务器端工作。更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分。
3).减轻服务器压力
服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；
4).共用一套后端程序代码
不用修改后端程序代码就可以同时用于Web界面、手机、平板等多种客户端；
- 2、缺点：
1).SEO难度较高
由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧。
2).前进、后退管理
由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现。
3).初次加载耗时多
为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理，如果使用第三方库，建议使用一些大公司的CDN，因此带宽的消耗是必然的

2、什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点
什么是前端路由
    路由是根据不同的url地址展示不同的内容或页面。前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前通过服务端根据url的不同返回不同的页面实现的
什么时候使用前端路由
    在单页面应用，大部分页面结构不变，只改变部分内容的使用
前端路由有什么优缺点
    优点：
用户体验好，不需要每次都从服务器全部获取，快速展现给用户
    缺点：
使用浏览器的前进，后退键的时候会重新发送请求，没有合理利用缓存
单页面无法记住之前滚动的位置，无法再前进，后退的时候记住滚动的位置。

3、Vue有哪些特点？或者叫vue的核心内容
轻量级    MVVM  自定义指令 虚拟DOM树 组件化开发

4、active-class是哪个组件的属性？嵌套路由怎么定义？
答：vue-router模块的router-link组件。

5、怎么定义vue-router的动态路由？怎么获取传过来的动态参数？ 
答：在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id

6、vue-router有哪几种导航钩子？    
答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件

7.指令keep-alive 是做什么的？
在vue-router写着keep-alive，keep-alive的含义： 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令 
<component :is='curremtView' keep-alive></component>

8、Vue怎么取消闪烁？
{}} 与v-text一样只不+过{{}}在渲染时可能有闪烁的显示双大括号
所以可以用v-text   v-html避免{{}}的闪烁效果也可以用v-cloak指令

9、我们用v-for循环的时候为什么要加:key，你怎么处理的？
vue1.0中有 track-by=“$index” 在2.0中使用 :key 替代 track-by ,Vue1.0中有$index这个特殊属性，2.0中移除了
以上是vue1.0支持$index,但是vue2.0不支持$index怎么办？换了一种写法v-for = “（item，index） in data”我们只要把值写成唯一的就可以为index就可以了
另外在vue2.0中使用：key 其实不写数组有重复的也会显示出来，只是写了性能会比较好
加上：key可以让虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)。所以一句话，key的作用主要是为了高效的更新虚拟DOM

10、如何让css只在当前组件中起作用在每一个vue组件中都可以定义各自的css，js，如果希望组件内写的css只对当前组件起作用，只需要在style中写入scoped，即：
<style scoped></style>
11、v-show指令，v-if的区别
 v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好

12、scss是什么？安装使用的步骤是？有哪几大特性？
答：预处理css，把css当前函数编写，定义变量,嵌套。 先装css-loader、node-loader、sass-loader等加载器模块，在webpack-base.config.js配置文件中加多一个拓展:extenstion，再加多一个模块：module里面test、loader

13、scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？
答：css的预编译。
使用步骤：
第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）
第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss
第三步：还是在同一个文件，配置一个module属性
第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”
有哪几大特性:
1、可以用变量，例如（$变量名称=值）；
2、可以用混合器，例如（）
3、可以嵌套

14、mint-ui是什么？怎么使用？说出至少三个组件使用方法？

答：基于vue的前端组件库。npm安装，然后import样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。组件一：Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper

15、v-model是什么？怎么使用？ vue中标签怎么绑定事件？

答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件：<input @click=doLog() />

16、axios是什么？怎么使用？描述使用它实现登录功能的流程？

答：请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中

17、vuex是什么？怎么使用？哪种功能场景使用它？

答：vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车

18、mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？

答：一个model+view+viewModel框架，数据模型model，viewModel连接两个
区别：vue数据驱动，通过数据来显示视图层而不是节点操作。
场景：数据操作比较多的场景，更加便捷

19、自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？

答：全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives
钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）
钩子函数参数：el、binding

20、说出至少4种vue当中的指令和它的用法？

答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定

21、vue-router是什么？它有哪些组件？

答：vue用来写路由一个插件。router-link、router-view

22、导航钩子有哪些？它们有哪些参数？

答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave
参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种

23、请详细说下你对vue生命周期的理解？

答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。
创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。
载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。
更新前/后：当data变化时，会触发beforeUpdate和updated方法。
销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在

24、请说下封装 vue 组件的过程？

答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。
然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。

26、你是怎么认识vuex的？

答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。
通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。
应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。
27、vue-loader是什么？使用它的用途有哪些？

答：解析.vue文件的一个加载器，跟template/js/style转换成js模块。

用途：js可以写es6、style样式可以scss或less、template可以加jade等

28、请说出vue.cli项目中src目录每个文件夹和文件的用法？

答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件

29、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？

答：第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default {
第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’
第三步：注入到vue的子组件的components属性上面,components:{smithButton}
第四步：在template视图view中使用，<smith-button>  </smith-button>
问题有：smithButton命名，使用的时候则smith-button。

30、vuejs与angularjs以及react的区别？
1.与AngularJS的区别
相同点：
都支持指令：内置指令和自定义指令。
都支持过滤器：内置过滤器和自定义过滤器。
都支持双向数据绑定。
都不支持低端浏览器。
不同点：
1.AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观。
2.在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢。
Vue.js使用基于依赖追踪的观察并且使用异步队列更新。所有的数据都是独立触发的。
对于庞大的应用来说，这个优化差异还是比较明显的。
2.与React的区别
相同点：
React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用。
中心思想相同：一切都是组件，组件实例之间可以嵌套。
都提供合理的钩子函数，可以让开发者定制化地去处理需求。
都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载。
在组件开发中都支持mixins的特性。
不同点：
React依赖Virtual DOM,而Vue.js使用的是DOM模板。React采用的Virtual DOM会对渲染出来的结果做脏检查。
Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作DOM。
### 14.vue插件
#### vuet 插件之 route
- 实现简易版 vue-cnode，实现列表点击详情返回后显示之前的数据
##### 第一步我们需要先安装 Vue、VueRouter、Vuet
```
npm install --save vue vue-router vuet
```
##### 第二步，我们创建 Vuet 的实例，vuet.js
```
import Vue from 'vue'
import Vuet from 'vuet'

Vue.use(Vuet)

const { fetch } = window

export default new Vuet({
  data () {
    return {}
  },
  modules: {
    cnode: { // 定义模块名称
      route: { // 要使用的插件
        list: { // 这里可以随便起个名称
          data () { // 定义这个数据的基本字段
            return {
              list: []
            }
          },
          watch: 'query', // route 插件的配置，如果有多个条件的话，可以设置一个数组
          fetch () { // 配置请求的方法，必须 return 一个 Promise
            const search = this.app.$route.fullPath.split('?')[1] || ''
            return fetch(`https://cnodejs.org/api/v1/topics?${search}`)
              .then(response => response.json())
              .then((res) => {
                return { list: res.data }
              })
          }
        },
        detail: { // 这里是详情，和列表页面同理
          data () {
            return {
              id: '',
              author_id: '',
              tab: '',
              content: '',
              title: '',
              last_reply_at: '',
              good: false,
              top: false,
              reply_count: 0,
              visit_count: 0,
              create_at: '',
              author: {
                loginname: '',
                avatar_url: ''
              },
              replies: [],
              is_collect: false
            }
          },
          watch: 'params.id',
          fetch () {
            return fetch(`https://cnodejs.org/api/v1/topic/${this.app.$route.params.id}`)
              .then(response => response.json())
              .then((res) => {
                return res.data
              })
          }
        }
      }
    }
  }
})

```
##### 第三步，我们创建 Vue 和 VueRouter 的实例，mian.js

```
import Vue from 'vue'
import VueRouter from 'vue-router'
import vuet from './vuet'
import List from './List'
import Detail from './Detail'

Vue.use(VueRouter)

// 配置路由相关
const router = new VueRouter({
  routes: [
    {
      path: '/',
      name: 'index',
      component: List
    },
    {
      path: '/:id',
      name: 'detail',
      component: Detail
    }
  ]
})

export default new Vue({
  el: '#app', // 这里是因为演示的目的，随便写的，根据你的程序写对应的初始化元素
  vuet, // 在 Vue 的根组件中安装 vuet
  router,
  render (h) {
    return h('router-view')
  }
})
```
##### 第四步，我们创建列表组件 List.vue

```
<template>
  <div>
    <header>
      <span v-for="(item, $index) in tabs" :key="item.value">
        <router-link :to="{ name: 'index', query: { tab: item.value } }">
          {{ item.label }}
        </router-link>
      </span>
    </header>
    <ul>
      <li v-for="(item, $index) in list.list" :key="item.id">
        <router-link :to="{ name: 'detail', params: { id: item.id } }">
          {{ item.title }}
        </router-link>
      </li>
    </ul>
  </div>
</template>
<script>
  import { mapMixins, mapState } from 'vuet'

  export default {
    mixins: [...mapMixins('cnode/route/list')], // 链接数据的更新逻辑
    data () {
      return {
        // 其实这里的数据是写死的数据，大家可以放到 local 插件中使用的。
        // 具体怎么用，大家自己发挥一下想象力咯
        tabs: [
          {
            label: '全部',
            value: 'all'
          },
          {
            label: '精华',
            value: 'good'
          },
          {
            label: '分享',
            value: 'share'
          },
          {
            label: '问答',
            value: 'ask'
          },
          {
            label: '招聘',
            value: 'job'
          }
        ]
      }
    },
    // 链接数据，重定向向为 list，这样 this.list.xxx 就能访问到我们 vuet 中的数据了
    // 哈哈，是不是好简单
    computed: mapState({ list: 'cnode/route/list' })
  }
</script>
```
##### 第五步，我们创建详情的组件，Detail.vue

```
<template>
  <div>
    <h2>{{ detail.title }}</h2>
    <article v-html="detail.content"></article>
  </div>
</template>
<script>
  import { mapMixins, mapState } from 'vuet'

  export default {
    mixins: [...mapMixins('cnode/route/detail')],
    computed: mapState({ detail: 'cnode/route/detail' })
  }
</script>
```