---
layout: post
title: "js方法手动实现"
date: 2019-06-12
tags: js

color: "rgb(154,133,255)"
---

## js 方法手动实现

### 1.实现 Object.assign(target,obj,obj1)

- Object.assign 是浅拷贝,对于值是引用类型的属性,拷贝仍旧的是它的引用
- 可以拷贝 Symbol 属性
- 不能拷贝不可枚举的属性
- Object.assign 保证 target 始终是一个对象,如果传入一个基本类型,会转为基本包装类型,null/undefined 没有基本包装类型,所以传入会报错
- source 参数如果是不可枚举的数据类型会忽略合并(字符串类型被认为是可枚举的,因为内部有 iterator 接口)
- 因为是用等号进行赋值,如果被赋值的对象的属性有 setter 函数会触发 setter 函数,同理如果有 getter 函数,也会调用赋值对象的属性的 getter 函数(这就是为什么 Object.assign 无法合并对象属性的访问器,因为它会直接执行对应的 getter/setter 函数而不是合并它们,如果需要合并对象属性的 getter/setter 函数,可以使用 ES7 提供的 Object.getOwnPropertyDescriptors 和 Object.defineProperties 这 2 个 API 实现)

```js
let obj = {
  // 这里是ES6新增的getter/setter简写形式
  get a() {
    console.log("get");
    return 1;
  },
  set a(val) {
    console.log("set");
  },
};
let obj2 = {};
Object.defineProperties(obj2, Object.getOwnPropertyDescriptors(obj));
console.log("obj", obj);
console.log("obj2", obj2);
// {}
// a: 1
// get a: ƒ a()
// set a: ƒ a(val)
```

模拟 Object.assign 的实现

```js
"use strict"; //启用严格模式在尝试给基本包装类型已定义的下标赋值的时候报错

const isComplexDataType = (obj) =>
  (typeof obj === "object" || typeof obj === "function") && obj !== null;

//简单实现ES6的Object.assign
const selfAssign = function (target, ...source) {
  if (target == null)
    throw new TypeError("Cannot convert undefined or null to object");
  return source.reduce((acc, cur) => {
    isComplexDataType(acc) || (acc = new Object(acc)); //变成一个基本包装类型
    if (cur == null) return acc; //source为null,undefined时忽略
    // 遍历出Symbol属性和可枚举属性
    [...Object.keys(cur), ...Object.getOwnPropertySymbols(cur)].forEach(
      (key) => {
        acc[key] = cur[key];
      }
    );
    return acc;
  }, target);
};

Object.selfAssign ||
  Object.defineProperty(Object, "selfAssign", {
    value: selfAssign,
    configurable: true,
    enumerable: false,
    writable: false,
  });

let target = {
  a: 1,
  b: 1,
};

let obj1 = {
  a: 2,
  b: 2,
  c: undefined,
};

let obj2 = {
  a: 3,
  b: 3,
  [Symbol("a")]: 3,
  d: null,
};

console.log(Object.selfAssign(target, obj1, obj2));
console.log(Object.selfAssign("abd", null, undefined));
```

### 2.实现函数 bind 方法

函数的 bind 方法核心是利用 call，同时考虑了一些其他情况，例如

- bind 返回的函数被 new 调用作为构造函数时，绑定的值会失效并且改为 new 指定的对象
- 定义了绑定后函数的 length 属性和 name 属性（不可枚举属性）
- 绑定后函数的原型需指向原来的函数

```js
const isComplexDataType = (obj) =>
  (typeof obj === "object" || typeof obj === "function") && obj !== null;

// 实现一个简易的bind
const selfBind = function (bindTarget, ...args1) {
  if (typeof this !== "function")
    throw new TypeError("Bind must be called on a function");
  let func = this;
  let boundFunc = function (...args2) {
    let args = [...args1, ...args2];

    // 使用new关键字调用返回新对象
    if (new.target) {
      let res = func.apply(this, args);
      //如果构造函数返回一个对象则返回这个对象
      if (isComplexDataType(res)) return res;
      //否则返回新建的对象
      return this;
    } else {
      func.apply(bindTarget, args);
    }
  };
  // 绑定后的函数继承绑定前的函数(非箭头函数)
  /**真正的bind创建的函数是没有prototype的,但是使用new会将创建的对象连接到bind前函数的prototype(非箭头函数)**/
  this.prototype && (boundFunc.prototype = Object.create(this.prototype));

  // 定义绑定后函数的长度和名字
  let desc = Object.getOwnPropertyDescriptors(func);
  Object.defineProperties(boundFunc, {
    length: desc.length,
    name: Object.assign(desc.name, {
      value: `bound ${desc.name.value}`,
    }),
  });
  return boundFunc;
};

Function.prototype.selfBind ||
  Object.defineProperty(Function.prototype, "selfBind", {
    value: selfBind,
    enumerable: false,
    configurable: true,
    writable: true,
  });

function func() {
  this.name = "yeyan1996";
  return {};
}

let example = {
  age: 22,
};

let boundFunc = func.selfBind(example);

console.dir(func);
console.dir(boundFunc);

boundFunc();
console.log(example);

let x = new boundFunc();
console.log(x);
```

### 3.实现函数 call 方法

```js
//selfCall(ES6版本)
const selfCall = function (context, ...args) {
  let func = this;
  context || (context = window);
  if (typeof func !== "function") throw new TypeError("this is not function");
  let caller = Symbol("caller");
  context[caller] = func;
  let res = context[caller](...args);
  delete context[caller];
  return res;
};

Function.prototype.selfCall ||
  Object.defineProperty(Function.prototype, "selfCall", {
    value: selfCall,
    enumerable: false,
    configurable: true,
    writable: true,
  });

let example2 = { a: 1 };
func.selfCall(example2);
console.log(example2);
```

原理就是将函数作为传入的上下文参数（context）的属性执行，这里为了防止属性冲突使用了 ES6 的 Symbol 类型

### 9. 实现 es6 的 class 语法

```js
//简单模拟ES6的class实现
// class Animal {
//     constructor(name) {
//         this.name = name
//     }
//
//     sleep() {
//         console.log('animal is sleeping')
//     }
//
//     static staticFunc() {
//         console.log('staticFunc')
//     }
// }
//
// class Dog extends Animal {
//     constructor(name, color) {
//         super(name)
//         this.color = color
//     }
//
//     barking() {
//         console.log('wang!')
//     }
// }
//
// let brownTeddy = new Dog('teddy', 'brown')
// Dog.staticFunc()
// console.log(brownTeddy)
// brownTeddy.sleep()
// brownTeddy.barking()

function Animal(name) {
  this.name = name;
}

Animal.staticFunc = function () {
  console.log("staticFunc");
};
Animal.prototype.sleep = function () {
  console.log("animal is sleeping");
};

function Dog(name, color) {
  Animal.call(this, name);
  this.color = color;
}

//寄生组合式继承 + 构造函数之间的继承
function inherit(subType, superType) {
  //由于JavaScript引用类型和函数按值传递的特性，不能改变subType的引用地址
  subType.prototype = Object.create(superType.prototype, {
    constructor: {
      enumerable: false,
      configurable: true,
      writable: true,
      // 指向子类，和默认的继承行为保持一致
      value: subType,
    },
  });
  //子构造函数继承父构造函数(子类继承父类的静态方法和静态属性)
  Object.setPrototypeOf(subType, superType);
}

inherit(Dog, Animal);

//需要在继承之后再往Dog中添加原型方法，否则会被覆盖掉
Dog.prototype.barking = function () {
  console.log("wang!");
};

let brownTeddy = new Dog("teddy", "brown");
Dog.staticFunc();
console.log(brownTeddy);
brownTeddy.sleep();
brownTeddy.barking();
```

### 10.函数柯里化

柯里化是函数式编程的一个重要技巧，将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术

```js
/**
 * @description 函数柯里化（根据柯里化前的函数的参数数量决定柯里化后的函数需要执行多少次）
 * @param {function} fn -柯里化的函数
 */

function curry(fn) {
  if (fn.length <= 1) return fn;
  const generator = (...args) => {
    if (fn.length === args.length) {
      //执行fn并且返回执行结果
      return fn(...args);
    } else {
      return (...args2) => {
        //返回generator函数
        return generator(...args, ...args2);
      };
    }
  };
  return generator;
}

const display = (a, b, c, d, e, f, g, h) => [a, b, c, d, e, f, g, h];
const curriedDisplay = curry(display);
console.log("curriedDisplay", curriedDisplay(1)(2)(3)(4)(5)(6)(7)(8));

//ES6简写
const curry2 = (fn) => {
  if (fn.length <= 1) return fn;
  const generator = (...args) =>
    args.length === fn.length
      ? fn(...args)
      : (...args2) => generator(...args, ...args2);
  return generator;
};
const curriedDisplay2 = curry2(display);
console.log("curriedDisplay2", curriedDisplay2(1)(2)(3)(4)(5)(6)(7)(8));

/**
 * @description 函数柯里化（支持占位符版本）
 * @param {function} fn -柯里化的函数
 * @param {String} [placeholder = "_"] -占位符
 */
const curry3 = (fn, placeholder = "_") => {
  curry3.placeholder = placeholder;
  if (fn.length <= 1) return fn;
  let argsList = [];
  const generator = (...args) => {
    let currentPlaceholderIndex = -1; // 记录了非当前轮最近的一个占位符下标，防止当前轮元素覆盖了当前轮的占位符
    args.forEach((arg) => {
      let placeholderIndex = argsList.findIndex(
        (item) => item === curry3.placeholder
      );
      if (placeholderIndex < 0) {
        // 如果数组中没有占位符直接往数组末尾放入一个元素
        currentPlaceholderIndex = argsList.push(arg) - 1;
        // 防止将元素填充到当前轮参数的占位符
        // (1,'_')('_',2) 数字2应该填充1后面的占位符，不能是2前面的占位符
      } else if (placeholderIndex !== currentPlaceholderIndex) {
        argsList[placeholderIndex] = arg;
      } else {
        // 当前元素是占位符的情况
        argsList.push(arg);
      }
    });
    let realArgsList = argsList.filter((arg) => arg !== curry3.placeholder); //过滤出不含占位符的数组
    if (realArgsList.length === fn.length) {
      return fn(...argsList);
    } else if (realArgsList.length > fn.length) {
      throw new Error("超出初始函数参数最大值");
    } else {
      return generator;
    }
  };

  return generator;
};
const curriedDisplay3 = curry3(display);
console.log(
  "curriedDisplay3",
  curriedDisplay3("_", 2)(1, "_", 4)(3, "_")("_", 5)(6)(7, 8)
);

//函数组合+函数柯里化
const compose = function (...fns) {
  return function (initValue) {
    return fns.reduceRight((acc, cur) => {
      return cur(acc);
    }, initValue);
  };
};

const curriedJoin = curry3((separator, arr) => arr.join(separator));
const curriedMap = curry3((fn, arr) => arr.map(fn));
const curriedSplit = curry3((separator, str) => str.split(separator));

const composeFunc = compose(
  curriedJoin("1"),
  curriedMap((item) => `${item}1`),
  curriedSplit("")
);

console.log("compose + curry", composeFunc("helloworld"));

/**
 * @description 偏函数（创建已经设置好一个或多个参数的函数,并且添加了占位符功能）
 * @param {Function} func -部分求值的函数
 * @param {...*} [args] -部分求值的参数
 * @return {Function} -部分求值后的函数
 **/

const partialFunc = (func, ...args) => {
  let placeholderNum = 0;
  return (...args2) => {
    args2.forEach((arg) => {
      let index = args.findIndex((item) => item === "_");
      if (index < 0) return;
      args[index] = arg;
      placeholderNum++;
    });
    if (placeholderNum < args2.length) {
      args2 = args2.slice(placeholderNum, args2.length);
    }
    return func.apply(this, [...args, ...args2]);
  };
};

let partialDisplay = partialFunc(display, 1, 2);
console.log("partialFunc", partialDisplay(3, 4, 5, 6, 7, 8));

let partialDisplay2 = partialFunc(display, "_", 2, "_");
console.log("partialFunc2", partialDisplay2(1, 3, 4, 5, 6, 7, 8));
```

### 11.函数防抖

```js
/**
 * @description 函数防抖
 * @param {Function} func -需要函数防抖的函数
 * @param {Number} time -延迟时间
 * @param {Options} options -配置项
 * @return {Function} -经过防抖处理的函数
 **/

/**
 * @typedef {Object} Options -配置项
 * @property {Boolean} leading -开始是否需要额外触发一次
 * @property {Boolean} trailing -结束后是否需要额外触发一次
 * @property {this} context -上下文
 **/

const debounce = (
  func,
  time = 17,
  options = {
    // leading 和 trailing 无法同时为 false
    leading: true,
    trailing: true,
    context: null,
  }
) => {
  let timer;
  const _debounce = function (...args) {
    if (timer) {
      clearTimeout(timer);
    }
    if (options.leading && !timer) {
      timer = setTimeout(null, time);
      func.apply(options.context, args);
    } else if (options.trailing) {
      timer = setTimeout(() => {
        func.apply(options.context, args);
        timer = null;
      }, time);
    }
  };
  /**
   * @description 取消函数
   * @see https://juejin.im/post/5931561fa22b9d0058c5b87d
   **/
  _debounce.cancel = function () {
    clearTimeout(timer);
    timer = null;
  };
  return _debounce;
};
```

### 12.优雅的处理 async/await

```js
// async/await 优雅处理方式
async function errorCaptured(asyncFunc) {
  try {
    let res = await asyncFunc();
    return [null, res];
  } catch (e) {
    return [e, null];
  }
}

let asyncFunc = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      Math.random() > 0.5 ? resolve("success") : reject("error");
    }, 1000);
  });
};

async function func() {
  let [err, res] = await errorCaptured(asyncFunc);
  console.log("res", res);
  console.log("err", err);
}

func();
```

### 13.手写 Promise

```js
// 我们用es5的自执行函数定义模块，如果用AMD规范的需要编译，用自执行函数方便我们一会调用测试
(function(window) {
  // 常量定义3promise的三个状态
  const PENDING = "pending";
  const FULFILLED = "fulfilled";
  const REJECTED = "rejected";
  // executor执行器，就是我们new Promise((resolve,reject)=>) 传过来的函数，它是同步执行的
  function Promise(executor) {
    // 存一下this，因为代码中调用resolve时，在全局下调用的，此时resolve里面this是window
    // 关于this指向问题，就是谁调用就指向谁，当然也可以用箭头函数处理这个问题
    const self = this;
    self.status = PENDING;
    self.state = undefined; //存传的值
    self.callbackQueues = []; // 存回调队列
    // 让promise成功的函数
    function resolve(value) {
      if (self.status !== PENDING) return;
      self.status = FULFILLED;
      self.state = value;
      /*
      这里会让人感到疑惑？下面是干什么的？
      onResolved是then方法的第一个参数，onRejected是第二个参数
      其实promise用了发布订阅的设计模式，promise把then方法的OnResolved和OnRejected方法存到一个数组里
      不懂没关系，可以看下面的我分析的代码执行步骤
    */
      if (self.callbackQueues.length > 0) {
        self.callbackQueues.map(item => {
          setTimeout(() => {
            item.onResolved(value);
          });
        });
      }
    }
    // 让promsie失败的函数
    function reject(reason) {
      // 如果不是pending状态，就没必要往下了，因为promise的状态一旦改变就无法在更改
      if (self.status !== PENDING) return;
      self.status = REJECTED;
      self.state = reason;

      if (self.callbackQueues.length > 0) {
        self.callbackQueues.map(item => {
          setTimeout(() => {
            item.onRejected(reason);
          });
        });
      }
    }
    // 捕获executor函数里意外错误，如果错误改变状态
    try {
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  /**
   * then方法指定了成功的和失败的回调函数,如果指定的不是函数，会忽略该值
   * 返回一个新的promise对象，该promsie的结果onResolved和onRejected决定，状态由上个Promise决定
   */
  Promise.prototype.then = function(onResolved, onRejected) {
    const self = this;
     // 如果传入的不是函数，就用默认函数，并把上一个promse的值往下传递
    const onResolved=typeof onResolved==='function'?onResolved:(value)=>value
     // 如果传入的不是函数，就给默认函数，并抛出错误，让返回的这个promsie为失败状态
    const onRejected=typeof onRejected==='function'?onRejected:(reason)=>throw reason
    /*
    我们为什么把判断写到promise里面？

    因为我们需要根据上一个Promsie的状态去改变当前这个返回的promise的状态
    上一个promsie的状态可以根据seft.status拿到，我们要改变返回的这个promise的状态，
    就是调用resolve或reject，我们只有写在promise里面才到调用这两个函数
   */
    return new Promise((reslove, reject) => {
       // 把相同的代码封装起来,并用try catch捕获错误
      /*
        像这种情况，使用者如果抛出错误，直接让下个promise也就是当前返回的promise状态为失败
       then(res=>{
         throw '我抛出错误'
       })
      */
    function handle (callback){
        try {
           const result= callback(self.state)
            if(result instance Promise){
              result.then(res=>{
                resolve(res)
              })
            } else {
                resolve(result)
          }
         }catch(reason){
          reject(reason)
        }
      }
      // 我们调用then方法的时候 ，promise可能是以下三种状

      // 如果是pending状态，那么说明Promsie内部的resolve还没执行，因为如果执行了，resolve函数会改变状态的
      // 由于resolve函数还未执行，我们也拿不到传过来的值，先把回调函数放到callbackQueues数组中
      if (self.status === PENDING) {
        self.callbackQueues.push({
          onResolved,
          onRejected
        });
      } else if (self.status === FULFILLED) {
        // 用self.state 拿到当前promsie state的值，把值传递给使用者传入的第一个回调函数
        // 我们调用onResolved拿到函数的返回值，这个返回值，也有可能是一个promise
        setTimeout(()=>{
            handle(onResolved)
         })
      } else {
        // 当前Promise 为rejected状态时，下面的实现方法跟上面基本一样
        // 为什么我们下面也调用resolve，因为onRejected这个函数中已经捕获了错误
        // 一旦有onRejected函数捕获了错误，错误就不再往下传递，让下一个promise成功！
        // 用self.state 拿到当前promsie state的值，把值传递给使用者传入的第二个回调函数
        setTimeout(()=>{
            handle(onRejected)
         })
      }
    });
  };
/**
  * 传入失败回调
  * 返回一个新的Promise
  */
 // 第一个参数不传，then里面会有默认参数，传入OnRejected回调函数
 // then 方法里会调用OnRejected并传入拒绝的理由
  Promise.prototype.catch = function(OnRejected) {
    return this.then(undefined,OnRejected)
  };
  /**
   * 返回一个指定结果成功的promise
   */
  Promise.resolve = function(value) {
    return new Promise((reslove,reject)=>{
        if(value instanceof Promise){
          value.then(resolve,reject)
        }else {
            resolve(value)
        }
    })
  };
  /**
   * 返回一个指定reason失败的promise
   */
  Promise.reject = function(reason) {
    return new Promise((reslove,reject)=>{
        reject(reason)
     })
  };
  /**
   * 所有成功才成功，有一个失败就失败
   * 返回一个的Promise，这个promise的结果由传过来的数组决定，一个失败就是失败
   */
  // 这个也不难，循环传入的数组，把成功的promise的返回的值放到values中
  // 只有当values和promises相同时，说明全部成功，这时候返回一个成功的数组，有一个失败就失败
  Promise.all = function(promises) {
    return new Promise((reslove,reject)=>{
      let values=[]
      promises.map(item=>{
        if(item instanceof Promise){
          item.then(res=>{
            values.push(res)
          },reject)
        }else{
           // 为了正确的放入values，所以也让其异步
            setTimeout(() => {
              values.push(item)
            })
        }
      })
       // 这里用setTiemeout是因上面的then方法是异步的，让下面的代码也异步，才能拿到最终的values数组
        setTimeout(() => {
          if (values.length === promises.length) {
            resolve(values)
          }
        })
    })
  };
 /**
 * 第一个成功就成功，如果不成功就失败(就是最先拿到谁的值，就成功)
 * 返回一个Promsie
 */
//  这个简单，只要发现一个promsie成功了，就让返回的promsie成功
  Promise.race = function(promises) {
    return new Promise((resolve,reject)=>{
        promises.map(item=>{
            if(item instanceof Promise) {
                item.then(
                    resolve
                    ,reject)
            }else {
                resolve(item)
            }
        })
    })
  };
  window.Promise = Promise;
})(window);
```

### 14.手写 前端状态管理器

```js
class PubSub {
  constructor() {
    //收集事件
    this.events = {};
  }
  //发布
  publish(event, data = {}) {
    const self = this;
    /*
     * 校验是否存在事件
     * 默认返回一个空数组
     */
    if (!self.events.hasOwnProperty(event)) {
      return [];
    }
    // 遍历执行事件队列里的回调函数
    return self.events[event].map((callback) => callback(data));
  }
  // 订阅
  subscribe(event, callback) {
    const self = this;

    /*
     * 校验是否存在事件
     * 默认给一个空数组
     */
    if (!self.events.hasOwnProperty(event)) {
      self.events[event] = [];
    }

    // 将事件推入回调队列
    return self.events[event].push(callback);
  }
}

class Store {
  // 传入params对象
  constructor(params) {
    const self = this;
    // 实例化发布订阅
    self.events = new PubSub();
    self.actions = {}; // 异步任务对象
    self.mutations = {}; // 同步任务对象
    self.state = {}; // 全局状态对象
    self.plugins = []; // 插件
    self.status = "resting"; // 初始状态

    /*
     * 初始化设置actions对象
     * 该对象主要处理异步事件
     */
    if (params.hasOwnProperty("actions")) {
      self.actions = params.actions;
    }

    /*
     * 初始化设置mutations对象
     * 该对象主要处理同步事件
     */
    if (params.hasOwnProperty("mutations")) {
      self.mutations = params.mutations;
    }

    // 插件
    if (params.hasOwnProperty("plugins")) {
      self.plugins = params.plugins;
    }

    /*
     * 代理监听state
     */
    self.state = new Proxy(params.state || {}, {
      set(state, key, value) {
        // 代理设置state对象并赋值
        state[key] = value;

        // 添加发布事件
        self.events.publish("stateChange", self.state);
        // 更改状态
        self.status = "resting";

        return true;
      },
    });
  }

  commit = (mutationKey, payload) => {
    const self = this;
    // 校验是否存在函数
    if (typeof self.mutations[mutationKey] !== "function") {
      console.warn(`Mutation ${mutationKey} dose not exist`);
      return false;
    }

    // 变更状态
    self.status = "mutation";
    let newState = self.mutations[mutationKey](self.state, payload);
    self.state = Object.assign(self.state, newState);

    return true;
  };
  dispatch = (actionKey, payload) => {
    const self = this;

    // 校验是否存在函数
    if (typeof self.actions[actionKey] !== "function") {
      console.warn(`Action ${actionKey} dose not exist`);
      return false;
    }

    // 变更状态
    self.status = "action";

    // 执行对应函数，并传入commit
    self.actions[actionKey]({ commit: self.commit }, payload);

    return true;
  };
}
// 实例场景
const MyStore = new Store({
  state: {
    text: "",
  },
  mutations: {
    init: (state, payload) => {
      state.text = payload;
    },
  },
  actions: {
    init: ({ commit }, payload) => {
      setTimeout(() => {
        commit("init", payload);
      }, 200);
    },
  },
  plugins: [
    function () {
      console.log("plugins");
    },
  ],
});

// 执行同步事件
MyStore.commit("init", "hello init");

// 执行异步事件
MyStore.dispatch("init", "hello async init");
```
