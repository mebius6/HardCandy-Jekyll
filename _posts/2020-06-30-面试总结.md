---
layout: post
title: "面试总结"
date: 20120-06-30
tags: 随笔

color: "rgb(154,133,255)"
---

### HTML&CSS：

- 浏览器内核
- 盒模型、flex 布局、两/三栏布局、水平/垂直居中；
- BFC、清除浮动；
- css3 动画、H5 新特性。

### JavaScript：

- 继承、原型链、this 指向、设计模式、call, apply, bind,；
- new 实现、防抖节流、let, var, const 区别、暂时性死区、event、loop；
- promise 使用及实现、promise 并行执行和顺序执行；
- async/await 的优缺点；
- 闭包、垃圾回收和内存泄漏、数组方法、数组乱序, 数组扁平化、事件委托、事件监听、事件模型

### Vue:

- vue 数据双向绑定原理；
- vue computed 原理、computed 和 watch 的区别；
- vue 编译器结构图、生命周期、vue 组件通信；
- mvvm 模式、mvc 模式理解；
- vue dom diff、vuex、vue-router

**网络：**

- HTTP1, HTTP2, HTTPS、常见的 http 状态码；
- 浏览从输入网址到回车发生了什么；
- 前端安全（CSRF、XSS）
- 前端跨域、浏览器缓存、cookie, session, token, localstorage, sessionstorage；
- TCP 连接(三次握手, 四次挥手)

**性能相关**

- 图片优化的方式
- 500 张图片，如何实现预加载优化
- 懒加载具体实现
- 减少 http 请求的方式
- webpack 如何配置大型项目

### 1\. 介绍一下 js 的数据类型有哪些,值是如何存储的

具体可看我之前的文章：[「前端料包」可能是最透彻的 JavaScript 数据类型详解](https://juejin.im/post/5dc6bfbcf265da4d2f31df25)

JavaScript 一共有 8 种数据类型，其中有 7 种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6 新增，表示独一无二的值）和 BigInt（es10 新增）；

1 种引用数据类型——Object（Object 本质上是由一组无序的名值对组成的）。里面包含 function、Array、Date 等。JavaScript 不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。

原始数据类型：直接存储在**栈**（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。

引用数据类型：同时存储在**栈**（stack）和**堆**（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

### 2\. && 、 ||和!! 运算符分别能做什么

- `&&` 叫逻辑与，在其操作数中找到第一个虚值表达式并返回它，如果没有找到任何虚值表达式，则返回最后一个真值表达式。它采用短路来防止不必要的工作。
- `||` 叫逻辑或，在其操作数中找到第一个真值表达式并返回它。这也使用了短路来防止不必要的工作。在支持 ES6 默认函数参数之前，它用于初始化函数中的默认参数值。
- `!!` 运算符可以将右侧的值强制转换为布尔值，这也是将值转换为布尔值的一种简单方法。

### 3\. js 的数据类型的转换

在 JS 中类型转换只有三种情况，分别是：

- 转换为布尔值（调用 Boolean()方法）
- 转换为数字（调用 Number()、parseInt()和 parseFloat()方法）
- 转换为字符串（调用.toString()或者 String()方法）

> null 和 underfined 没有.toString 方法

![](https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

此外还有一些操作符会存在隐式转换，此处不做展开，可自行百度 00

### 4\. JS 中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()

**（1）typeof**

typeof 对于原始类型来说，除了 null 都可以显示正确的类型

    console.log(typeof 2);               // number
    console.log(typeof true);            // boolean
    console.log(typeof 'str');           // string
    console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object
    console.log(typeof function(){});    // function
    console.log(typeof {});              // object
    console.log(typeof undefined);       // undefined
    console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object
    复制代码

typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof

**（2）instanceof**

instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。

    console.log(2 instanceof Number);                    // false
    console.log(true instanceof Boolean);                // false
    console.log('str' instanceof String);                // false
    console.log([] instanceof Array);                    // true
    console.log(function(){} instanceof Function);       // true
    console.log({} instanceof Object);                   // true
    // console.log(undefined instanceof Undefined);
    // console.log(null instanceof Null);
    复制代码

可以看出直接的字面量值判断数据类型，instanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被 instanceof 精准判断。

我们来看一下 instanceof  在 MDN 中的解释：instanceof  运算符用来测试一个对象在其原型链中是否存在一个构造函数的  prototype  属性。其意思就是判断对象是否是某一数据类型（如 Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，'str'不是实例，所以判断值为 false。

**（3）constructor**

    console.log((2).constructor === Number); // true
    console.log((true).constructor === Boolean); // true
    console.log(('str').constructor === String); // true
    console.log(([]).constructor === Array); // true
    console.log((function() {}).constructor === Function); // true
    console.log(({}).constructor === Object); // true
    复制代码

> 这里有一个坑，如果我创建一个对象，更改它的原型，constructor 就会变得不可靠了

    function Fn(){};

    Fn.prototype=new Array();

    var f=new Fn();

    console.log(f.constructor===Fn);    // false
    console.log(f.constructor===Array); // true
    复制代码

**（4）Object.prototype.toString.call()** 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用 Object 的 toString 方法

    var a = Object.prototype.toString;

    console.log(a.call(2));
    console.log(a.call(true));
    console.log(a.call('str'));
    console.log(a.call([]));
    console.log(a.call(function(){}));
    console.log(a.call({}));
    console.log(a.call(undefined));
    console.log(a.call(null));
    复制代码

### 5\. 介绍 js 有哪些内置对象？

js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函 数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构 造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。

涉及知识点：

    全局的对象（ global objects ）或称标准内置对象，不要和 "全局对象（global object）" 混淆。这里说的全局的对象是说在
    全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。

    标准内置对象的分类

    （1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。

    例如 Infinity、NaN、undefined、null 字面量

    （2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。

    例如 eval()、parseFloat()、parseInt() 等

    （3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。

    例如 Object、Function、Boolean、Symbol、Error 等

    （4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。

    例如 Number、Math、Date

    （5）字符串，用来表示和操作字符串的对象。

    例如 String、RegExp

    （6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array

    （7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。

    例如 Map、Set、WeakMap、WeakSet

    （8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。

    例如 SIMD 等

    （9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。

    例如 JSON 等

    （10）控制抽象对象

    例如 Promise、Generator 等

    （11）反射

    例如 Reflect、Proxy

    （12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。

    例如 Intl、Intl.Collator 等

    （13）WebAssembly

    （14）其他

    例如 arguments

    复制代码

详细资料可以参考： [《标准内置对象的分类》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)

[《JS 所有内置对象属性和方法汇总》](https://segmentfault.com/a/1190000011467723#articleHeader24)

### 6\. undefined 与 undeclared 的区别？

已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。

对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 "undefined"。

### 7\. null 和 undefined 的区别？

首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。

undefined 代表的含义是未定义， null 代表的含义是空对象（其实不是真的对象，请看下面的**注意**！）。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。

> 其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它 会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。

当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等 号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。

详细资料可以参考：

[《JavaScript 深入理解之 undefined 与 null》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bundefined%E4%B8%8Enull.html)

### 8\. {} 和 \[\] 的 valueOf 和 toString 的结果是什么？

    {} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"

    [] 的 valueOf 结果为 [] ，toString 的结果为 ""
    复制代码

### 9\. Javascript 的作用域和作用域链

**作用域：** 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。

**作用域链：** 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。

作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。

作用域链的创建过程跟执行上下文的建立有关....

详细资料可以参考： [《JavaScript 深入理解之作用域链》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html)

也可以看看我的文章：[「前端料包」深究 JavaScript 作用域（链）知识点和闭包](https://juejin.im/post/5e93e4eaf265da47fc0ce177)

### 10\. javascript 创建对象的几种方式？

    我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js
    和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象
    创建方式，我了解到的方式有这么几种：

    （1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。

    （2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。

    （3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。

    （4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。

    （5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。

    （6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。

    嗯我目前了解到的就是这么几种方式。
    复制代码

详细资料可以参考： [《JavaScript 深入理解之对象创建》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html)

### 11\. JavaScript 继承的几种实现方式？

    我了解的 js 中实现继承的几种方式有：

    （1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

    （2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

    （3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

    （4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。

    （5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。

    （6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。
    复制代码

详细资料可以参考： [《JavaScript 深入理解之继承》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html)

### 12\. 寄生式组合继承的实现？

    function Person(name) {
      this.name = name;
    }

    Person.prototype.sayName = function() {
      console.log("My name is " + this.name + ".");
    };

    function Student(name, grade) {
      Person.call(this, name);
      this.grade = grade;
    }

    Student.prototype = Object.create(Person.prototype);
    Student.prototype.constructor = Student;

    Student.prototype.sayMyGrade = function() {
      console.log("My grade is " + this.grade + ".");

    };
    复制代码

### 13\. 谈谈你对 this、call、apply 和 bind 的理解

详情可看我之前的文章：[「前端料包」一文彻底搞懂 JavaScript 中的 this、call、apply 和 bind](https://juejin.im/post/5de4fe1d5188255e8b76e1f2)

1.  在浏览器里，在全局范围内 this 指向 window 对象；
2.  在函数中，this 永远指向最后调用他的那个对象；
3.  构造函数中，this 指向 new 出来的那个新的对象；
4.  call、apply、bind 中的 this 被强绑定在指定的那个对象上；
5.  箭头函数中 this 比较特殊,箭头函数 this 为父作用域的 this，不是调用时的 this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的 this 指向是静态的,声明的时候就确定了下来；
6.  apply、call、bind 都是 js 给函数内置的一些 API，调用他们可以为函数指定 this 的执行,同时也可以传参。

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="549"></svg>)

### 14\. JavaScript 原型，原型链？ 有什么特点？

在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对 象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部 将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们 是不应该能够获取到这个值的，但是现在浏览器中都实现了 **proto** 属性来让我们访问这个属性，但是我们最好不要使用这 个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对 象的原型。

当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。

特点：

JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与 之相关的对象也会继承这一改变。

参考文章：

[《JavaScript 深入理解之原型与原型链》](http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html)

也可以看看我写的：[「前端料包」深入理解 JavaScript 原型和原型链](https://juejin.im/post/5e860b5e518825738d526a22)

### 15\. js 获取原型的方法？

- p.**proto**
- p.constructor.prototype
- Object.getPrototypeOf(p)

### 16\. 什么是闭包，为什么要用它？

**闭包是指有权访问另一个函数作用域内变量的函数**，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。

闭包有两个常用的用途。

- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

  function a(){
  var n = 0;
  function add(){
  n++;
  console.log(n);
  }
  return add;
  }
  var a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；
  a1(); //1
  a1(); //2 第二次调用 n 变量还在内存中

  复制代码

其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。

### 17\. 什么是 DOM 和 BOM？

**DOM** 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。

**BOM** 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM 的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局） 对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对 象的子对象。

相关资料：

[《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》](https://www.zhihu.com/question/33453164)

[《Window 对象》](http://www.w3school.com.cn/jsref/dom_obj_window.asp)

[《DOM 与 BOM 分别是什么，有何关联？》](https://www.zhihu.com/question/20724662)

[《JavaScript 学习总结（三）BOM 和 DOM 详解》](https://segmentfault.com/a/1190000000654274#articleHeader21)

### 18\. 三种事件模型是什么？

**事件** 是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。

1.  **DOM0 级模型：** ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。
2.  **IE 事件模型：** 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。
3.  **DOM2 级事件模型：** 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。

相关资料：

[《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》](https://blog.csdn.net/u013217071/article/details/77613706)

### 19\. 事件委托是什么？

**事件委托** 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到 目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。

相关资料：

[《JavaScript 事件委托详解》](https://zhuanlan.zhihu.com/p/26536815)

### 20\. 什么是事件传播?

当**事件**发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在“当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。

事件传播有三个阶段：

1.  捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或 event.target。
2.  目标阶段–事件已达到目标元素。
3.  冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。

### 21\. 什么是事件捕获？

当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从 window 开始，一直到触发事件的元素。`window----> document----> html----> body ---->目标元素`

假设有如下的 HTML 结构：

    <div class="grandparent">
      <div class="parent">
        <div class="child">1</div>
      </div>
    </div>
    复制代码

对应的 JS 代码:

    function addEvent(el, event, callback, isCapture = false) {
      if (!el || !event || !callback || typeof callback !== 'function') return;
      if (typeof el === 'string') {
        el = document.querySelector(el);
      };
      el.addEventListener(event, callback, isCapture);
    }

    addEvent(document, 'DOMContentLoaded', () => {
      const child = document.querySelector('.child');
      const parent = document.querySelector('.parent');
      const grandparent = document.querySelector('.grandparent');

      addEvent(child, 'click', function (e) {
        console.log('child');
      });

      addEvent(parent, 'click', function (e) {
        console.log('parent');
      });

      addEvent(grandparent, 'click', function (e) {
        console.log('grandparent');
      });

      addEvent(document, 'click', function (e) {
        console.log('document');
      });

      addEvent('html', 'click', function (e) {
        console.log('html');
      })

      addEvent(window, 'click', function (e) {
        console.log('window');
      })

    });
    复制代码

`addEventListener`方法具有第三个可选参数`useCapture`，其默认值为`false`，事件将在冒泡阶段中发生，如果为 true，则事件将在捕获阶段中发生。如果单击`child`元素，它将分别在控制台上打印`window`，`document`，`html`，`grandparent`和`parent`，这就是**事件捕获**。

### 22\. 什么是事件冒泡？

事件冒泡刚好与事件捕获相反，`当前元素---->body ----> html---->document ---->window`。当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达 window 为止。

假设有如下的 HTML 结构：

    <div class="grandparent">
      <div class="parent">
        <div class="child">1</div>
      </div>
    </div>
    复制代码

对应的 JS 代码：

    function addEvent(el, event, callback, isCapture = false) {
      if (!el || !event || !callback || typeof callback !== 'function') return;
      if (typeof el === 'string') {
        el = document.querySelector(el);
      };
      el.addEventListener(event, callback, isCapture);
    }

    addEvent(document, 'DOMContentLoaded', () => {
      const child = document.querySelector('.child');
      const parent = document.querySelector('.parent');
      const grandparent = document.querySelector('.grandparent');

      addEvent(child, 'click', function (e) {
        console.log('child');
      });

      addEvent(parent, 'click', function (e) {
        console.log('parent');
      });

      addEvent(grandparent, 'click', function (e) {
        console.log('grandparent');
      });

      addEvent(document, 'click', function (e) {
        console.log('document');
      });

      addEvent('html', 'click', function (e) {
        console.log('html');
      })

      addEvent(window, 'click', function (e) {
        console.log('window');
      })

    });
    复制代码

`addEventListener`方法具有第三个可选参数`useCapture`，其默认值为`false`，事件将在冒泡阶段中发生，如果为 true，则事件将在捕获阶段中发生。如果单击`child`元素，它将分别在控制台上打印`child`，`parent`，`grandparent`，`html`，`document`和`window`，这就是**事件冒泡**。

### 23\. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？

（1）创建新节点

      createDocumentFragment()    //创建一个DOM片段
      createElement()   //创建一个具体的元素
      createTextNode()   //创建一个文本节点
    复制代码

（2）添加、移除、替换、插入

    appendChild(node)
    removeChild(node)
    replaceChild(new,old)
    insertBefore(new,old)
    复制代码

（3）查找

    getElementById();
    getElementsByName();
    getElementsByTagName();
    getElementsByClassName();
    querySelector();
    querySelectorAll();
    复制代码

（4）属性操作

    getAttribute(key);
    setAttribute(key, value);
    hasAttribute(key);
    removeAttribute(key);
    复制代码

相关资料：

[《DOM 概述》](https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction#DOM_interfaces)

[《原生 JavaScript 的 DOM 操作汇总》](https://harttle.land/2015/10/01/javascript-dom-api.html)

[《原生 JS 中 DOM 节点相关 API 合集》](https://microzz.com/2017/04/06/jsdom/)

### 24\. js 数组和对象有哪些原生方法,列举一下

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1089" height="712"></svg>)

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1092" height="638"></svg>)

### 25\. 常用的正则表达式（仅做收集，涉及不深）

    //（1）匹配 16 进制颜色值
    var color = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;

    //（2）匹配日期，如 yyyy-mm-dd 格式
    var date = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;

    //（3）匹配 qq 号
    var qq = /^[1-9][0-9]{4,10}$/g;

    //（4）手机号码正则
    var phone = /^1[34578]\d{9}$/g;

    //（5）用户名正则
    var username = /^[a-zA-Z\$][a-zA-Z0-9_\$]{4,16}$/;

    //（6）Email正则
    var email = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;

    //（7）身份证号（18位）正则
    var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;

    //（8）URL正则
    var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;

    // (9)ipv4地址正则
    var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

    // (10)//车牌号正则
    var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;

    // (11)强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：var pwd = /^(?=.\d)(?=.[a-z])(?=.[A-Z]).{8,10}$/
    复制代码

### 26\. Ajax 是什么? 如何创建一个 Ajax？

我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。

#### 创建步骤：

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="557" height="102"></svg>)

#### 面试手写（原生）：

    //1：创建Ajax对象
    var xhr = window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject('Microsoft.XMLHTTP');// 兼容IE6及以下版本
    //2：配置 Ajax请求地址
    xhr.open('get','index.xml',true);
    //3：发送请求
    xhr.send(null); // 严谨写法
    //4:监听请求，接受响应
    xhr.onreadysatechange=function(){
         if(xhr.readySates==4&&xhr.status==200 || xhr.status==304 )
              console.log(xhr.responsetXML)
    }

    复制代码

#### jQuery 写法

      $.ajax({
              type:'post',
              url:'',
              async:ture,//async 异步  sync  同步
              data:data,//针对post请求
              dataType:'jsonp',
              success:function (msg) {

              },
              error:function (error) {

              }
            })

    复制代码

#### promise 封装实现：

    // promise 封装实现：

    function getJSON(url) {
      // 创建一个 promise 对象
      let promise = new Promise(function(resolve, reject) {
        let xhr = new XMLHttpRequest();

        // 新建一个 http 请求
        xhr.open("GET", url, true);

        // 设置状态的监听函数
        xhr.onreadystatechange = function() {
          if (this.readyState !== 4) return;

          // 当请求成功或失败时，改变 promise 的状态
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error(this.statusText));
          }
        };

        // 设置错误监听函数
        xhr.onerror = function() {
          reject(new Error(this.statusText));
        };

        // 设置响应的数据类型
        xhr.responseType = "json";

        // 设置请求头信息
        xhr.setRequestHeader("Accept", "application/json");

        // 发送 http 请求
        xhr.send(null);
      });

      return promise;
    }
    复制代码

### 27\. js 延迟加载的方式有哪些？

js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。

我了解到的几种方式是：

1.  将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。
2.  给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。
3.  给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。
4.  动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。

相关资料：

[《JS 延迟加载的几种方式》](https://blog.csdn.net/meijory/article/details/76389762)

[《HTML 5 `<script>` `async` 属性》](http://www.w3school.com.cn/html5/att_script_async.asp)

### 28\. 谈谈你对模块化开发的理解？

我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念 ，但随着程序越来越复杂，代码的模块化开发变得越来越重要。

由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污 染，并且模块间没有联系。

后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所 有的所有的模块成员，外部代码可以修改内部属性的值。

现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。

相关资料： [《浅谈模块化开发》](https://juejin.im/post/5ab378c46fb9a028ce7b824f)

[《Javascript 模块化编程（一）：模块的写法》](http://www.ruanyifeng.com/blog/2012/10/javascript_module.html)

[《前端模块化：CommonJS，AMD，CMD，ES6》](https://juejin.im/post/5aaa37c8f265da23945f365c)

[《Module 的语法》](http://es6.ruanyifeng.com/#docs/module)

### 29\. js 的几种模块规范？

js 中现在比较成熟的有四种模块加载方案：

- 第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。
- 第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。
- 第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。
- 第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。

### 30\. AMD 和 CMD 规范的区别？

它们之间的主要区别有两个方面。

1.  第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。
2.  第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。

    // CMD
    define(function(require, exports, module) {
    var a = require("./a");
    a.doSomething();
    // 此处略去 100 行
    var b = require("./b"); // 依赖可以就近书写
    b.doSomething();
    // ...
    });

    // AMD 默认推荐
    define(["./a", "./b"], function(a, b) {
    // 依赖必须一开始就写好
    a.doSomething();
    // 此处略去 100 行
    b.doSomething();
    // ...
    });
    复制代码

相关资料：

[《前端模块化，AMD 与 CMD 的区别》](https://juejin.im/post/5a422b036fb9a045211ef789)

### 31\. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。

- 1.`CommonJS` 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。`CommonJS` 模块输出的是值的

，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。

- 2.`CommonJS` 模块是运行时加载，ES6 模块是编译时输出接口。`CommonJS` 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

### 32\. requireJS 的核心原理是什么？

require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。```

详细资料可以参考： [《requireJS 的用法和原理分析》](https://github.com/HRFE/blog/issues/10)

[《requireJS 的核心原理是什么？》](https://zhuanlan.zhihu.com/p/55039478)

[《requireJS 原理分析》](https://www.jianshu.com/p/5a39535909e4)

### 33\. 谈谈 JS 的运行机制

#### 1\. js 单线程

JavaScript 语言的一大特点就是单线程，即同一时间只能做一件事情。

> JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

#### 2\. js 事件循环

js 代码执行过程中会有很多任务，这些任务总的分成两类：

- 同步任务
- 异步任务

当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1148" height="960"></svg>)

我们解释一下这张图：

- 同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入`Event Table`并注册函数。
- 当指定的事情完成时，`Event Table`会将这个函数移入`Event Queue`。
- 主线程内的任务执行完毕为空，会去`Event Queue`读取对应的函数，进入主线程执行。
- 上述过程会不断重复，也就是常说的`Event Loop`(事件循环)。

那主线程执行栈何时为空呢？js 引擎存在`monitoring process`进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去`Event Queue`那里检查是否有等待被调用的函数。

以上就是 js 运行的整体流程

需要注意的是除了同步任务和异步任务，任务还可以更加细分为 macrotask(宏任务)和 microtask(微任务)，js 引擎会优先执行微任务

    微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。

    宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲
    染等。
    复制代码

面试中该如何回答呢？ 下面是我个人推荐的回答：

1.  首先 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。
2.  在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务
3.  当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。
4.  任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。
5.  当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。

最后可以用下面一道题检测一下收获：

    setTimeout(function() {
      console.log(1)
    }, 0);
    new Promise(function(resolve, reject) {
      console.log(2);
      resolve()
    }).then(function() {
      console.log(3)
    });
    process.nextTick(function () {
      console.log(4)
    })
    console.log(5)

    复制代码

第一轮：主线程开始执行，遇到 setTimeout，将 setTimeout 的回调函数丢到宏任务队列中，在往下执行 new Promise 立即执行，输出 2，then 的回调函数丢到微任务队列中，再继续执行，遇到 process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出 5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有 then 函数和 nextTick 两个微任务，先执行哪个呢？process.nextTick 指定的异步任务总是发生在所有异步任务之前，因此先执行 process.nextTick 输出 4 然后执行 then 函数输出 3，第一轮执行结束。 第二轮：从宏任务队列开始，发现 setTimeout 回调，输出 1 执行完毕，因此结果是 25431

相关资料：

[《浏览器事件循环机制（event loop）》](https://juejin.im/post/5afbc62151882542af04112d)

[《详解 JavaScript 中的 Event Loop（事件循环）机制》](https://zhuanlan.zhihu.com/p/33058983)

[《什么是 Event Loop？》](http://www.ruanyifeng.com/blog/2013/10/event_loop.html)

[《这一次，彻底弄懂 JavaScript 执行机制》](https://juejin.im/post/59e85eebf265da430d571f89)

### 34\. arguments 的对象是什么？

arguments 对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个 length 属性，我们可以使用数组索引表示法 arguments\[1\]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter 和 map。

我们可以使用 Array.prototype.slice 将 arguments 对象转换成一个数组。

    function one() {
      return Array.prototype.slice.call(arguments);
    }
    复制代码

注意:箭头函数中没有 arguments 对象。

    function one() {
      return arguments;
    }
    const two = function () {
      return arguments;
    }
    const three = function three() {
      return arguments;
    }

    const four = () => arguments;

    four(); // Throws an error  - arguments is not defined
    复制代码

当我们调用函数 four 时，它会抛出一个`ReferenceError: arguments is not defined error`。使用 rest 语法，可以解决这个问题。

    const four = (...args) => args;
    复制代码

这会自动将所有参数值放入数组中。

### 35\. 为什么在调用这个函数时，代码中的`b`会变成一个全局变量?

    function myFunc() {
      let a = b = 0;
    }

    myFunc();
    复制代码

原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：

    function myFunc() {
      let a = (b = 0);
    }

    myFunc();
    复制代码

首先，表达式 b = 0 求值，在本例中 b 没有声明。因此，JS 引擎在这个函数外创建了一个全局变量 b，之后表达式 b = 0 的返回值为 0，并赋给新的局部变量 a。

我们可以通过在赋值之前先声明变量来解决这个问题。

    function myFunc() {
      let a,b;
      a = b = 0;
    }
    myFunc();
    复制代码

### 36\. 简单介绍一下 V8 引擎的垃圾回收机制

    v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。

    新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

    新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：

    （1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。

    （2）如果对象不存活，则释放对象的空间。

    （3）最后将 From 空间和 To 空间角色进行交换。

    新生代对象晋升到老生代有两个条件：

    （1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

    （2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。

    老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。

    由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。
    复制代码

相关资料：

[《深入理解 V8 的垃圾回收原理》](https://www.jianshu.com/p/b8ed21e8a4fb)

[《JavaScript 中的垃圾回收》](https://zhuanlan.zhihu.com/p/23992332)

### 37\. 哪些操作会造成内存泄漏？

- 1.意外的全局变量
- 2.被遗忘的计时器或回调函数
- 3.脱离 DOM 的引用
- 4.闭包

- 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
- 第二种情况是我们设置了`setInterval`定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
- 第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
- 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。

相关资料：

[《JavaScript 内存泄漏教程》](http://www.ruanyifeng.com/blog/2017/04/memory-leak.html)

[《4 类 JavaScript 内存泄漏及如何避免》](https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/)

[《杜绝 js 中四种内存泄漏类型的发生》](https://juejin.im/entry/5a64366c6fb9a01c9332c706)

[《javascript 典型内存泄漏及 chrome 的排查方法》](https://segmentfault.com/a/1190000008901861)

> 以下 38~46 条是 ECMAScript 2015(ES6)中常考的基础知识点

### 38\. ECMAScript 是什么？

ECMAScript 是编写脚本语言的标准，这意味着 JavaScript 遵循 ECMAScript 标准中的规范变化，因为它是 JavaScript 的蓝图。

ECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件 只不过发明 JavaScript 的那个人（Netscape 公司），把东西交给了 ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有 java 语言了，又想强调这个东西是让 ECMA 这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做 ECMAScript。

javaScript = ECMAScript + DOM + BOM（自认为是一种广义的 JavaScript）

ECMAScript 说什么 JavaScript 就得做什么！

JavaScript（狭义的 JavaScript）做什么都要问问 ECMAScript 我能不能这样干！如果不能我就错了！能我就是对的！

——突然感觉 JavaScript 好没有尊严，为啥要搞个人出来约束自己，

那个人被创造出来也好委屈，自己被创造出来完全是因为要约束 JavaScript。

### 39\. ECMAScript 2015（ES6）有哪些新特性？

- 块作用域
- 类
- 箭头函数
- 模板字符串
- 加强的对象字面
- 对象解构
- Promise
- 模块
- Symbol
- 代理（proxy）Set
- 函数默认参数
- rest 和展开

### 40\. `var`,`let`和`const`的区别是什么？

var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会：

    var a = 100;
    console.log(a,window.a);    // 100 100

    let b = 10;
    console.log(b,window.b);    // 10 undefined

    const c = 1;
    console.log(c,window.c);    // 1 undefined
    复制代码

var 声明变量存在变量提升，let 和 const 不存在变量提升:

    console.log(a); // undefined  ===>  a已声明还没赋值，默认得到undefined值
    var a = 100;

    console.log(b); // 报错：b is not defined  ===> 找不到b这个变量
    let b = 10;

    console.log(c); // 报错：c is not defined  ===> 找不到c这个变量
    const c = 10;
    复制代码

let 和 const 声明形成块作用域

    if(1){
      var a = 100;
      let b = 10;
    }

    console.log(a); // 100
    console.log(b)  // 报错：b is not defined  ===> 找不到b这个变量

    -------------------------------------------------------------

    if(1){
      var a = 100;
      const c = 1;
    }
    console.log(a); // 100
    console.log(c)  // 报错：c is not defined  ===> 找不到c这个变量
    复制代码

同一作用域下 let 和 const 不能声明同名变量，而 var 可以

    var a = 100;
    console.log(a); // 100

    var a = 10;
    console.log(a); // 10
    -------------------------------------
    let a = 100;
    let a = 10;

    //  控制台报错：Identifier 'a' has already been declared  ===> 标识符a已经被声明了。
    复制代码

暂存死区

    var a = 100;

    if(1){
        a = 10;
        //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，
        // 而这时，还未到声明时候，所以控制台Error:a is not defined
        let a = 1;
    }
    复制代码

const

    /*
    * &emsp;&emsp;1、一旦声明必须赋值,不能使用null占位。
    *
    * &emsp;&emsp;2、声明后不能再修改
    *
    * &emsp;&emsp;3、如果声明的是复合类型数据，可以修改其属性
    *
    * */

    const a = 100;

    const list = [];
    list[0] = 10;
    console.log(list);&emsp;&emsp;// [10]

    const obj = {a:100};
    obj.name = 'apple';
    obj.a = 10000;
    console.log(obj);&emsp;&emsp;// {a:10000,name:'apple'}
    复制代码

### 41\. 什么是箭头函数？

箭头函数表达式的语法比函数表达式更简洁，并且没有自己的`this，arguments，super或new.target`。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。

    //ES5 Version
    var getCurrentDate = function (){
      return new Date();
    }

    //ES6 Version
    const getCurrentDate = () => new Date();
    复制代码

在本例中，ES5 版本中有`function(){}`声明和 return 关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要()括号，不需要 return 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。

    //ES5 Version
    function greet(name) {
      return 'Hello ' + name + '!';
    }

    //ES6 Version
    const greet = (name) => `Hello ${name}`;
    const greet2 = name => `Hello ${name}`;
    复制代码

我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。

    const getArgs = () => arguments

    const getArgs2 = (...rest) => rest
    复制代码

箭头函数不能访问 arguments 对象。所以调用第一个 getArgs 函数会抛出一个错误。相反，我们可以使用 rest 参数来获得在箭头函数中传递的所有参数。

    const data = {
      result: 0,
      nums: [1, 2, 3, 4, 5],
      computeResult() {
        // 这里的“this”指的是“data”对象
        const addAll = () => {
          return this.nums.reduce((total, cur) => total + cur, 0)
        };
        this.result = addAll();
      }
    };
    复制代码

箭头函数没有自己的 this 值。它捕获词法作用域函数的 this 值，在此示例中，addAll 函数将复制 computeResult 方法中的 this 值，如果我们在全局作用域声明箭头函数，则 this 值为 window 对象。

### 42\. 什么是类？

类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。

     //ES5 Version
       function Person(firstName, lastName, age, address){
          this.firstName = firstName;
          this.lastName = lastName;
          this.age = age;
          this.address = address;
       }

       Person.self = function(){
         return this;
       }

       Person.prototype.toString = function(){
         return "[object Person]";
       }

       Person.prototype.getFullName = function (){
         return this.firstName + " " + this.lastName;
       }

       //ES6 Version
       class Person {
            constructor(firstName, lastName, age, address){
                this.lastName = lastName;
                this.firstName = firstName;
                this.age = age;
                this.address = address;
            }

            static self() {
               return this;
            }

            toString(){
               return "[object Person]";
            }

            getFullName(){
               return `${this.firstName} ${this.lastName}`;
            }
       }
    复制代码

重写方法并从另一个类继承。

    //ES5 Version
    Employee.prototype = Object.create(Person.prototype);

    function Employee(firstName, lastName, age, address, jobTitle, yearStarted) {
      Person.call(this, firstName, lastName, age, address);
      this.jobTitle = jobTitle;
      this.yearStarted = yearStarted;
    }

    Employee.prototype.describe = function () {
      return `I am ${this.getFullName()} and I have a position of ${this.jobTitle} and I started at ${this.yearStarted}`;
    }

    Employee.prototype.toString = function () {
      return "[object Employee]";
    }

    //ES6 Version
    class Employee extends Person { //Inherits from "Person" class
      constructor(firstName, lastName, age, address, jobTitle, yearStarted) {
        super(firstName, lastName, age, address);
        this.jobTitle = jobTitle;
        this.yearStarted = yearStarted;
      }

      describe() {
        return `I am ${this.getFullName()} and I have a position of ${this.jobTitle} and I started at ${this.yearStarted}`;
      }

      toString() { // Overriding the "toString" method of "Person"
        return "[object Employee]";
      }
    }
    复制代码

所以我们要怎么知道它在内部使用原型？

    class Something {

    }

    function AnotherSomething(){

    }
    const as = new AnotherSomething();
    const s = new Something();

    console.log(typeof Something); // "function"
    console.log(typeof AnotherSomething); // "function"
    console.log(as.toString()); // "[object Object]"
    console.log(as.toString()); // "[object Object]"
    console.log(as.toString === Object.prototype.toString); // true
    console.log(s.toString === Object.prototype.toString); // true
    复制代码

相关资料：

[《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》](https://www.zhihu.com/question/29789315)

[《Class 的基本语法》](http://es6.ruanyifeng.com/#docs/class)

### 43\. 什么是模板字符串？

模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。

    //ES5 Version
    var greet = 'Hi I\'m Mark';

    //ES6 Version
    let greet = `Hi I'm Mark`;
    复制代码

在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦：

    //ES5 Version
    var lastWords = '\n'
      + '   I  \n'
      + '   Am  \n'
      + 'Iron Man \n';


    //ES6 Version
    let lastWords = `
        I
        Am
      Iron Man
    `;
    复制代码

在 ES5 版本中，我们需要添加\\n 以在字符串中添加新行。在模板字符串中，我们不需要这样做。

    //ES5 Version
    function greet(name) {
      return 'Hello ' + name + '!';
    }


    //ES6 Version
    function greet(name) {
      return `Hello ${name} !`;
    }
    复制代码

在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用`+`运算符。在模板字符串 s 中，我们可以使用`${expr}`嵌入一个表达式，这使其比 ES5 版本更整洁。

### 44\. 什么是对象解构？

对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象：

    const employee = {
      firstName: "Marko",
      lastName: "Polo",
      position: "Software Developer",
      yearHired: 2017
    };
    复制代码

从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。

    var firstName = employee.firstName;
    var lastName = employee.lastName;
    var position = employee.position;
    var yearHired = employee.yearHired;
    复制代码

使用解构方式语法就变得简洁多了：

    { firstName, lastName, position, yearHired } = employee;
    复制代码

我们还可以为属性取别名：

    let { firstName: fName, lastName: lName, position, yearHired } = employee;
    复制代码

当然如果属性值为 undefined 时，我们还可以指定默认值：

    let { firstName = "Mark", lastName: lName, position, yearHired } = employee;
    复制代码

### 45\. 什么是`Set`对象，它是如何工作的？

Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。

我们可以使用 Set 构造函数创建 Set 实例。

    const set1 = new Set();
    const set2 = new Set(["a","b","c","d","d","e"]);
    复制代码

我们可以使用 add 方法向 Set 实例中添加一个新值，因为 add 方法返回 Set 对象，所以我们可以以链式的方式再次使用 add。如果一个值已经存在于 Set 对象中，那么它将不再被添加。

    set2.add("f");
    set2.add("g").add("h").add("i").add("j").add("k").add("k");
    // 后一个“k”不会被添加到set对象中，因为它已经存在了
    复制代码

我们可以使用 has 方法检查 Set 实例中是否存在特定的值。

    set2.has("a") // true
    set2.has("z") // true
    复制代码

我们可以使用 size 属性获得 Set 实例的长度。

    set2.size // returns 10
    复制代码

可以使用 clear 方法删除 Set 中的数据。

    set2.clear();
    复制代码

我们可以使用 Set 对象来删除数组中重复的元素。

    const numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];
    const uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]
    复制代码

另外还有`WeakSet`， 与 `Set` 类似，也是不重复的值的集合。但是 `WeakSet` 的成员只能是对象，而不能是其他类型的值。`WeakSet` 中的对象都是弱引用，即垃圾回收机制不考虑 `WeakSet`对该对象的引用。

- Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。

- WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。

### 46\. 什么是 Proxy？

Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

> 高能预警 ⚡⚡⚡， 以下 47~64 条是 JavaScript 中比较难的高级知识及相关手写实现，各位看官需慢慢细品

### 47\. 写一个通用的事件侦听器函数

    const EventUtils = {
      // 视能力分别使用dom0||dom2||IE方式 来绑定事件
      // 添加事件
      addEvent: function(element, type, handler) {
        if (element.addEventListener) {
          element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
          element.attachEvent("on" + type, handler);
        } else {
          element["on" + type] = handler;
        }
      },

      // 移除事件
      removeEvent: function(element, type, handler) {
        if (element.removeEventListener) {
          element.removeEventListener(type, handler, false);
        } else if (element.detachEvent) {
          element.detachEvent("on" + type, handler);
        } else {
          element["on" + type] = null;
        }
      },

      // 获取事件目标
      getTarget: function(event) {
        return event.target || event.srcElement;
      },

      // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event
      getEvent: function(event) {
        return event || window.event;
      },

      // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）
      stopPropagation: function(event) {
        if (event.stopPropagation) {
          event.stopPropagation();
        } else {
          event.cancelBubble = true;
        }
      },

      // 取消事件的默认行为
      preventDefault: function(event) {
        if (event.preventDefault) {
          event.preventDefault();
        } else {
          event.returnValue = false;
        }
      }
    };
    复制代码

### 48\. 什么是函数式编程? JavaScript 的哪些特性使其成为函数式语言的候选语言？

函数式编程（通常缩写为 FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。

函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。

函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 \- 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。

### 49\. 什么是高阶函数？

高阶函数只是将函数作为参数或返回值的函数。

    function higherOrderFunction(param,callback){
        return callback(param);
    }
    复制代码

### 50\. 为什么函数被称为一等公民？

在 JavaScript 中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:

- 赋值（`var func = function(){}`）、
- 传参(`function func(x,callback){callback();}`)、
- 返回(`function(){return function(){}}`)，

这样的函数也称之为第一级函数（`First-class Function`）。不仅如此，JavaScript 中的函数还充当了类的构造函数的作用，同时又是一个 Function 类的实例(instance)。这样的多重身份让 JavaScript 的函数变得非常重要。

### 51\. 手动实现 `Array.prototype.map 方法`

map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

    function map(arr, mapCallback) {
      // 首先，检查传递的参数是否正确。
      if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') {
        return [];
      } else {
        let result = [];
        // 每次调用此函数时，我们都会创建一个 result 数组
        // 因为我们不想改变原始数组。
        for (let i = 0, len = arr.length; i < len; i++) {
          result.push(mapCallback(arr[i], i, arr));
          // 将 mapCallback 返回的结果 push 到 result 数组中
        }
        return result;
      }
    }
    复制代码

### 52\. 手动实现`Array.prototype.filter`方法

`filter()`方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。

    function filter(arr, filterCallback) {
      // 首先，检查传递的参数是否正确。
      if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function')
      {
        return [];
      } else {
        let result = [];
         // 每次调用此函数时，我们都会创建一个 result 数组
         // 因为我们不想改变原始数组。
        for (let i = 0, len = arr.length; i < len; i++) {
          // 检查 filterCallback 的返回值是否是真值
          if (filterCallback(arr[i], i, arr)) {
          // 如果条件为真，则将数组元素 push 到 result 中
            result.push(arr[i]);
          }
        }
        return result; // return the result array
      }
    }
    复制代码

### 53\. 手动实现`Array.prototype.reduce`方法

reduce() 方法对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。

    function reduce(arr, reduceCallback, initialValue) {
      // 首先，检查传递的参数是否正确。
      if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== 'function')
      {
        return [];
      } else {
        // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue
        let hasInitialValue = initialValue !== undefined;
        let value = hasInitialValue ? initialValue : arr[0];
       、

        // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始
        for (let i = hasInitialValue ? 0 : 1, len = arr.length; i < len; i++) {
          value = reduceCallback(value, arr[i], i, arr);
        }
        return value;
      }
    }
    复制代码

### 54\. js 的深浅拷贝

JavaScript 的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础版的。所以在写这条之前我拜读了收藏夹里各路大佬写的博文。具体可以看下面我贴的链接，这里只做简单的总结。

- **浅拷贝：** 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。
- **深拷贝：** 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。

**浅拷贝的实现方式：**

- **Object.assign() 方法：** 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
- \*\*Array.prototype.slice()：\*\*slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end（不包括 end）决定的原数组的浅拷贝。原始数组不会被改变。
- **拓展运算符`...`：**

  let a = {
  name: "Jake",
  flag: {
  title: "better day by day",
  time: "2020-05-31"
  }
  }
  let b = {...a};
  复制代码

**深拷贝的实现方式：**

- **乞丐版：** JSON.parse(JSON.stringify(object))，缺点诸多（会忽略 undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）
- **基础版（面试够用）：** 浅拷贝+递归 （只考虑了普通的 object 和 array 两种数据类型）

  function cloneDeep(target,map = new WeakMap()) {
  if(typeOf taret ==='object'){
  let cloneTarget = Array.isArray(target) ? [] : {};

  if(map.get(target)) {
  return target;
  }
  map.set(target, cloneTarget);
  for(const key in target){
  cloneTarget[key] = cloneDeep(target[key], map);
  }
  return cloneTarget
  }else{
  return target
  }

  }

  复制代码

- **终极版：**

  const mapTag = '[object Map]';
  const setTag = '[object Set]';
  const arrayTag = '[object Array]';
  const objectTag = '[object Object]';
  const argsTag = '[object Arguments]';

  const boolTag = '[object Boolean]';
  const dateTag = '[object Date]';
  const numberTag = '[object Number]';
  const stringTag = '[object String]';
  const symbolTag = '[object Symbol]';
  const errorTag = '[object Error]';
  const regexpTag = '[object RegExp]';
  const funcTag = '[object Function]';

  const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];

  function forEach(array, iteratee) {
  let index = -1;
  const length = array.length;
  while (++index < length) {
  iteratee(array[index], index);
  }
  return array;
  }

  function isObject(target) {
  const type = typeof target;
  return target !== null && (type === 'object' || type === 'function');
  }

  function getType(target) {
  return Object.prototype.toString.call(target);
  }

  function getInit(target) {
  const Ctor = target.constructor;
  return new Ctor();
  }

  function cloneSymbol(targe) {
  return Object(Symbol.prototype.valueOf.call(targe));
  }

  function cloneReg(targe) {
  const reFlags = /\w\*\$/;
  const result = new targe.constructor(targe.source, reFlags.exec(targe));
  result.lastIndex = targe.lastIndex;
  return result;
  }

  function cloneFunction(func) {
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  if (func.prototype) {
  const param = paramReg.exec(funcString);
  const body = bodyReg.exec(funcString);
  if (body) {
  if (param) {
  const paramArr = param[0].split(',');
  return new Function(...paramArr, body[0]);
  } else {
  return new Function(body[0]);
  }
  } else {
  return null;
  }
  } else {
  return eval(funcString);
  }
  }

  function cloneOtherType(targe, type) {
  const Ctor = targe.constructor;
  switch (type) {
  case boolTag:
  case numberTag:
  case stringTag:
  case errorTag:
  case dateTag:
  return new Ctor(targe);
  case regexpTag:
  return cloneReg(targe);
  case symbolTag:
  return cloneSymbol(targe);
  case funcTag:
  return cloneFunction(targe);
  default:
  return null;
  }
  }

  function clone(target, map = new WeakMap()) {

      // 克隆原始类型
      if (!isObject(target)) {
          return target;
      }

      // 初始化
      const type = getType(target);
      let cloneTarget;
      if (deepTag.includes(type)) {
          cloneTarget = getInit(target, type);
      } else {
          return cloneOtherType(target, type);
      }

      // 防止循环引用
      if (map.get(target)) {
          return map.get(target);
      }
      map.set(target, cloneTarget);

      // 克隆set
      if (type === setTag) {
          target.forEach(value => {
              cloneTarget.add(clone(value, map));
          });
          return cloneTarget;
      }

      // 克隆map
      if (type === mapTag) {
          target.forEach((value, key) => {
              cloneTarget.set(key, clone(value, map));
          });
          return cloneTarget;
      }

      // 克隆对象和数组
      const keys = type === arrayTag ? undefined : Object.keys(target);
      forEach(keys || target, (value, key) => {
          if (keys) {
              key = value;
          }
          cloneTarget[key] = clone(target[key], map);
      });

      return cloneTarget;

  }

  module.exports = {
  clone
  };
  复制代码

参考文章：

[如何写出一个惊艳面试官的深拷贝](https://mp.weixin.qq.com/s/vXbFsG59L1Ba0DMcZeU2Bg)

[深拷贝的终极探索（99%的人都不知道）](https://segmentfault.com/a/1190000016672263)

### 55\. 手写 call、apply 及 bind 函数

**call 函数的实现步骤：**

- 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
- 2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。
- 3.处理传入的参数，截取第一个参数后的所有参数。
- 4.将函数作为上下文对象的一个属性。
- 5.使用上下文对象来调用这个方法，并保存返回结果。
- 6.删除刚才新增的属性。
- 7.返回结果。

  // call 函数实现
  Function.prototype.myCall = function(context) {
  // 判断调用对象
  if (typeof this !== "function") {
  console.error("type error");
  }

  // 获取参数
  let args = [...arguments].slice(1),
  result = null;

  // 判断 context 是否传入，如果未传入则设置为 window
  context = context || window;

  // 将调用函数设为对象的方法
  context.fn = this;

  // 调用函数
  result = context.fn(...args);

  // 将属性删除
  delete context.fn;

  return result;
  };
  复制代码

**apply 函数的实现步骤：**

- 1.  判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
- 2.  判断传入上下文对象是否存在，如果不存在，则设置为 window 。
- 3.  将函数作为上下文对象的一个属性。
- 4.  判断参数值是否传入
- 4.  使用上下文对象来调用这个方法，并保存返回结果。
- 5.  删除刚才新增的属性
- 6.  返回结果

  // apply 函数实现

  Function.prototype.myApply = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
  throw new TypeError("Error");
  }

  let result = null;

  // 判断 context 是否存在，如果未传入则为 window
  context = context || window;

  // 将函数设为对象的方法
  context.fn = this;

  // 调用方法
  if (arguments[1]) {
  result = context.fn(...arguments[1]);
  } else {
  result = context.fn();
  }

  // 将属性删除
  delete context.fn;

  return result;
  };

  复制代码

**bind 函数的实现步骤：**

- 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
- 2.保存当前函数的引用，获取其余传入参数值。
- 3.创建一个函数返回
- 4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。

  // bind 函数实现
  Function.prototype.myBind = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
  throw new TypeError("Error");
  }

  // 获取参数
  var args = [...arguments].slice(1),
  fn = this;

  return function Fn() {
  // 根据调用方式，传入不同绑定值
  return fn.apply(
  this instanceof Fn ? this : context,
  args.concat(...arguments)
  );
  };
  };
  复制代码

参考文章： [《手写 call、apply 及 bind 函数》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe)

[《JavaScript 深入之 call 和 apply 的模拟实现》](https://github.com/mqyqingfeng/Blog/issues/11)

### 56\. 函数柯里化的实现

    // 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。

    function curry(fn, args) {
      // 获取函数需要的参数长度
      let length = fn.length;

      args = args || [];

      return function() {
        let subArgs = args.slice(0);

        // 拼接得到现有的所有参数
        for (let i = 0; i < arguments.length; i++) {
          subArgs.push(arguments[i]);
        }

        // 判断参数的长度是否已经满足函数所需参数的长度
        if (subArgs.length >= length) {
          // 如果满足，执行函数
          return fn.apply(this, subArgs);
        } else {
          // 如果不满足，递归返回科里化的函数，等待参数的传入
          return curry.call(this, fn, subArgs);
        }
      };
    }

    // es6 实现
    function curry(fn, ...args) {
      return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);
    }
    复制代码

参考文章： [《JavaScript 专题之函数柯里化》](https://github.com/mqyqingfeng/Blog/issues/42)

### 57\. js 模拟 new 操作符的实现

这个问题如果你在掘金上搜，你可能会搜索到类似下面的回答：

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1027" height="315"></svg>)

说实话，看第一遍，我是不理解的，我需要去理一遍原型及原型链的知识才能理解。所以我觉得[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)对 new 的解释更容易理解：

`new` 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。`new` 关键字会进行如下的操作：

1.  创建一个空的简单 JavaScript 对象（即{}）；
2.  链接该对象（即设置该对象的构造函数）到另一个对象 ；
3.  将步骤 1 新创建的对象作为 this 的上下文 ；
4.  如果该函数没有返回对象，则返回 this。

接下来我们看实现：

    function Dog(name, color, age) {
      this.name = name;
      this.color = color;
      this.age = age;
    }

    Dog.prototype={
      getName: function() {
        return this.name
      }
    }

    var dog = new Dog('大黄', 'yellow', 3)

    复制代码

上面的代码相信不用解释，大家都懂。我们来看最后一行带`new`关键字的代码，按照上述的 1,2,3,4 步来解析`new`背后的操作。

第一步：创建一个简单空对象

    var obj = {}
    复制代码

第二步：链接该对象到另一个对象（原型链）

    // 设置原型链
    obj.__proto__ = Dog.prototype
    复制代码

第三步：将步骤 1 新创建的对象作为 `this` 的上下文

    // this指向obj对象
    Dog.apply(obj, ['大黄', 'yellow', 3])
    复制代码

第四步：如果该函数没有返回对象，则返回 this

    // 因为 Dog() 没有返回值，所以返回obj
    var dog = obj
    dog.getName() // '大黄'
    复制代码

需要注意的是如果 Dog() 有 return 则返回 return 的值

    var rtnObj = {}
    function Dog(name, color, age) {
      // ...
      //返回一个对象
      return rtnObj
    }

    var dog = new Dog('大黄', 'yellow', 3)
    console.log(dog === rtnObj) // true

    复制代码

接下来我们将以上步骤封装成一个对象实例化方法，即模拟 new 的操作：

    function objectFactory(){
        var obj = {};
        //取得该方法的第一个参数(并删除第一个参数)，该参数是构造函数
        var Constructor = [].shift.apply(arguments);
        //将新对象的内部属性__proto__指向构造函数的原型，这样新对象就可以访问原型中的属性和方法
        obj.__proto__ = Constructor.prototype;
        //取得构造函数的返回值
        var ret = Constructor.apply(obj, arguments);
        //如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象
        return typeof ret === "object" ? ret : obj;
    }

    复制代码

### 58\. 什么是回调函数？回调函数有什么缺点

**回调函数**是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。

在 JavaScript 中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。

    const btnAdd = document.getElementById('btnAdd');

    btnAdd.addEventListener('click', function clickCallback(e) {
        // do something useless
    });
    复制代码

在本例中，我们等待 id 为`btnAdd`的元素中的`click`事件，如果它被单击，则执行`clickCallback`函数。回调函数向某些数据或事件添加一些功能。

回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个事件存在依赖性：

    setTimeout(() => {
        console.log(1)
        setTimeout(() => {
            console.log(2)
            setTimeout(() => {
                console.log(3)

            },3000)

        },2000)
    },1000)
    复制代码

这就是典型的回调地狱，以上代码看起来不利于阅读和维护，事件一旦多起来就更是乱糟糟，所以在 es6 中提出了 Promise 和 async/await 来解决回调地狱的问题。当然，回调函数还存在着别的几个缺点，比如不能使用 try catch 捕获错误，不能直接 return。接下来的两条就是来解决这些问题的，咱们往下看。

### 59\. Promise 是什么，可以手写实现一下吗？

Promise，翻译过来是承诺，承诺它过一段时间会给你一个结果。从编程讲 Promise 是异步编程的一种解决方案。下面是 Promise 在[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)的相关说明：

Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的 promise 对象。

一个 Promise 有以下几种状态:

- pending: 初始状态，既不是成功，也不是失败状态。
- fulfilled: 意味着操作成功完成。
- rejected: 意味着操作失败。

这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 fulfilled/rejected 后，就不能再次改变。 可能光看概念大家不理解 Promise，我们举个简单的栗子；

假如我有个女朋友，下周一是她生日，我答应她生日给她一个惊喜，那么从现在开始这个承诺就进入等待状态，等待下周一的到来，然后状态改变。如果下周一我如约给了女朋友惊喜，那么这个承诺的状态就会由 pending 切换为 fulfilled，表示承诺成功兑现，一旦是这个结果了，就不会再有其他结果，即状态不会在发生改变；反之如果当天我因为工作太忙加班，把这事给忘了，说好的惊喜没有兑现，状态就会由 pending 切换为 rejected，时间不可倒流，所以状态也不能再发生变化。

上一条我们说过 Promise 可以解决回调地狱的问题，没错，pending 状态的 Promise 对象会触发 fulfilled/rejected 状态，一旦状态改变，Promise 对象的 then 方法就会被调用；否则就会触发 catch。我们将上一条回调地狱的代码改写一下：

    new Promise((resolve，reject) => {
         setTimeout(() => {
                console.log(1)
                resolve()
            },1000)

    }).then((res) => {
        setTimeout(() => {
                console.log(2)
            },2000)
    }).then((res) => {
        setTimeout(() => {
                console.log(3)
            },3000)
    }).catch((err) => {
    console.log(err)
    })
    复制代码

其实 Promise 也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。

**promise 手写实现，面试够用版：**

    function myPromise(constructor){
        let self=this;
        self.status="pending" //定义状态改变前的初始状态
        self.value=undefined;//定义状态为resolved的时候的状态
        self.reason=undefined;//定义状态为rejected的时候的状态
        function resolve(value){
            //两个==="pending"，保证了状态的改变是不可逆的
           if(self.status==="pending"){
              self.value=value;
              self.status="resolved";
           }
        }
        function reject(reason){
            //两个==="pending"，保证了状态的改变是不可逆的
           if(self.status==="pending"){
              self.reason=reason;
              self.status="rejected";
           }
        }
        //捕获构造异常
        try{
           constructor(resolve,reject);
        }catch(e){
           reject(e);
        }
    }
    // 定义链式调用的then方法
    myPromise.prototype.then=function(onFullfilled,onRejected){
       let self=this;
       switch(self.status){
          case "resolved":
            onFullfilled(self.value);
            break;
          case "rejected":
            onRejected(self.reason);
            break;
          default:
       }
    }

    复制代码

关于 Promise 还有其他的知识，比如 Promise.all()、Promise.race()等的运用，由于篇幅原因就不再做展开，想要深入了解的可看下面的文章。

相关资料：

[「硬核 JS」深入了解异步解决方案](https://juejin.im/post/5e4613b36fb9a07ccc45e339#heading-69)

[【翻译】Promises/A+规范](https://www.ituring.com.cn/article/66566#)

### 60\. `Iterator`是什么，有什么作用？

`Iterator`是理解第 24 条的先决知识，也许是我 IQ 不够 😭，`Iterator和Generator`看了很多遍还是一知半解，即使当时理解了，过一阵又忘得一干二净。。。

Iterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

**Iterator 语法：**

    const obj = {
        [Symbol.iterator]:function(){}
    }

    复制代码

`[Symbol.iterator]`属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历。

迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 next 方法，改变指针的指向，让其指向下一条数据 每一次的 next 都会返回一个对象，该对象有两个属性

- value 代表想要获取的数据
- done 布尔值，false 表示当前指针指向的数据有值，true 表示遍历已经结束

**Iterator 的作用有三个：**

1.  为各种数据结构，提供一个统一的、简便的访问接口；
2.  使得数据结构的成员能够按某种次序排列；
3.  ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。

**遍历过程：**

1.  创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。
2.  第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。
3.  第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。
4.  不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。

每一次调用 next 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 value 和 done 两个属性的对象。其中，value 属性是当前成员的值，done 属性是一个布尔值，表示遍历是否结束。

    let arr = [{num:1},2,3]
    let it = arr[Symbol.iterator]() // 获取数组中的迭代器
    console.log(it.next()) 	// { value: Object { num: 1 }, done: false }
    console.log(it.next()) 	// { value: 2, done: false }
    console.log(it.next()) 	// { value: 3, done: false }
    console.log(it.next()) 	// { value: undefined, done: true }

    复制代码

### 61\. `Generator`函数是什么，有什么作用？

Generator 函数可以说是 Iterator 接口的具体实现方式。Generator 最大的特点就是可以控制函数的执行。

    function *foo(x) {
      let y = 2 * (yield (x + 1))
      let z = yield (y / 3)
      return (x + y + z)
    }
    let it = foo(5)
    console.log(it.next())   // => {value: 6, done: false}
    console.log(it.next(12)) // => {value: 8, done: false}
    console.log(it.next(13)) // => {value: 42, done: true}

    复制代码

上面这个示例就是一个 Generator 函数，我们来分析其执行过程：

- `首先 Generator 函数调用时它会返回一个迭代器`
- `当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6`
- `当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8`
- `当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42`

`Generator` 函数一般见到的不多，其实也于他有点绕有关系，并且一般会配合 co 库去使用。当然，我们可以通过 `Generator` 函数解决回调地狱的问题。

### 62\. 什么是 `async/await` 及其如何工作,有什么优缺点？

`async/await`是一种建立在 Promise 之上的编写异步或非阻塞代码的新方法，被普遍认为是 JS 异步操作的最终且最优雅的解决方案。相对于 Promise 和回调，它的可读性和简洁度都更高。毕竟一直 then()也很烦。

`async` 是异步的意思，而 `await` 是 `async wait`的简写，即异步等待。

所以从语义上就很好理解 async 用于声明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。

一个函数如果加上 async ，那么该函数就会返回一个 Promise

    async function test() {
      return "1"
    }
    console.log(test()) // -> Promise {<resolved>: "1"}
    复制代码

可以看到输出的是一个 Promise 对象。所以，async 函数返回的是一个 Promise 对象，如果在 async 函数中直接 return 一个直接量，async 会把这个直接量通过 `PromIse.resolve()`封装成 Promise 对象返回。

相比于 `Promise`，`async/await`能更好地处理 then 链

    function takeLongTime(n) {
        return new Promise(resolve => {
            setTimeout(() => resolve(n + 200), n);
        });
    }

    function step1(n) {
        console.log(`step1 with ${n}`);
        return takeLongTime(n);
    }

    function step2(n) {
        console.log(`step2 with ${n}`);
        return takeLongTime(n);
    }

    function step3(n) {
        console.log(`step3 with ${n}`);
        return takeLongTime(n);
    }

    复制代码

现在分别用 `Promise` 和`async/await`来实现这三个步骤的处理。

**使用 Promise**

    function doIt() {
        console.time("doIt");
        const time1 = 300;
        step1(time1)
            .then(time2 => step2(time2))
            .then(time3 => step3(time3))
            .then(result => {
                console.log(`result is ${result}`);
            });
    }
    doIt();
    // step1 with 300
    // step2 with 500
    // step3 with 700
    // result is 900

    复制代码

**使用`async/await`**

    async function doIt() {
        console.time("doIt");
        const time1 = 300;
        const time2 = await step1(time1);
        const time3 = await step2(time2);
        const result = await step3(time3);
        console.log(`result is ${result}`);
    }
    doIt();
    复制代码

结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，优雅整洁，几乎跟同步代码一样。

> await 关键字只能在 async function 中使用。在任何非 async function 的函数中使用 await 关键字都会抛出错误。await 关键字在执行下一行代码之前等待右侧表达式(可能是一个 Promise)返回。

**优缺点：**

`async/await`的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。

参考文章：

[「硬核 JS」深入了解异步解决方案](https://juejin.im/post/5e4613b36fb9a07ccc45e339#heading-69)

`以上21~25条就是JavaScript中主要的异步解决方案了，难度是有的，需要好好揣摩并加以练习。`

### 63\. instanceof 的原理是什么，如何实现

instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。

实现 instanceof：

1.  首先获取类型的原型
2.  然后获得对象的原型
3.  然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null

    function myInstanceof(left, right) {
    let prototype = right.prototype
    left = left.**proto**
    while (true) {
    if (left === null || left === undefined)
    return false
    if (prototype === left)
    return true
    left = left.**proto**
    }
    }
    复制代码

### 64\. js 的节流与防抖

**函数防抖** 是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。

**函数节流** 是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。

    // 函数防抖的实现
    function debounce(fn, wait) {
      var timer = null;

      return function() {
        var context = this,
          args = arguments;

        // 如果此时存在定时器的话，则取消之前的定时器重新记时
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }

        // 设置定时器，使事件间隔指定事件后执行
        timer = setTimeout(() => {
          fn.apply(context, args);
        }, wait);
      };
    }

    // 函数节流的实现;
    function throttle(fn, delay) {
      var preTime = Date.now();

      return function() {
        var context = this,
          args = arguments,
          nowTime = Date.now();

        // 如果两次时间间隔超过了指定时间，则执行函数。
        if (nowTime - preTime >= delay) {
          preTime = Date.now();
          return fn.apply(context, args);
        }
      };
    }
    复制代码

详细资料可以参考：

[《轻松理解 JS 函数节流和函数防抖》](https://juejin.im/post/5a35ed25f265da431d3cc1b1)

[《JavaScript 事件节流和事件防抖》](https://juejin.im/post/5aa60b0e518825556b6c6d1a)

[《JS 的防抖与节流》](https://juejin.im/entry/5b1d2d54f265da6e2545bfa4)

### 65\. 什么是设计模式？

#### 1\. 概念

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。

#### 2\. 设计原则

1.  **S – Single Responsibility Principle 单一职责原则**

    - 一个程序只做好一件事
    - 如果功能过于复杂就拆分开，每个部分保持独立

2.  **O – OpenClosed Principle 开放/封闭原则**

    - 对扩展开放，对修改封闭
    - 增加需求时，扩展新代码，而非修改已有代码

3.  **L – Liskov Substitution Principle 里氏替换原则**

    - 子类能覆盖父类
    - 父类能出现的地方子类就能出现

4.  **I – Interface Segregation Principle 接口隔离原则**

    - 保持接口的单一独立
    - 类似单一职责原则，这里更关注接口

5.  **D – Dependency Inversion Principle 依赖倒转原则**

    - 面向接口编程，依赖于抽象而不依赖于具
    - 使用方只关注接口而不关注具体类的实现

#### 3\. 设计模式的类型

1.  **结构型模式（Structural Patterns）：** 通过识别系统中组件间的简单关系来简化系统的设计。
2.  **创建型模式（Creational Patterns）：** 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。
3.  **行为型模式（Behavioral Patterns）：** 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。

### 66\. 9 种前端常见的设计模式

#### 1\. 外观模式（Facade Pattern）

外观模式是最常见的设计模式之一，它为子系统中的一组接口提供一个统一的高层接口，使子系统更容易使用。简而言之外观设计模式就是把多个子系统中复杂逻辑进行抽象，从而提供一个更统一、更简洁、更易用的 API。很多我们常用的框架和库基本都遵循了外观设计模式，比如 JQuery 就把复杂的原生 DOM 操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。其实在平时工作中我们也会经常用到外观模式进行开发，只是我们不自知而已。

1.  兼容浏览器事件绑定

    let addMyEvent = function (el, ev, fn) {
    if (el.addEventListener) {
    el.addEventListener(ev, fn, false)
    } else if (el.attachEvent) {
    el.attachEvent('on' + ev, fn)
    } else {
    el['on' + ev] = fn
    }
    };
    复制代码

2.  封装接口

    let myEvent = {
    // ...
    stop: e => {
    e.stopPropagation();
    e.preventDefault();
    }
    };
    复制代码

**场景**

- 设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观 Facade
- 在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少他们之间的依赖。
- 在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观 Facade 也是非常合适的，为系系统开发一个外观 Facade 类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和 Facade 对象交互，Facade 与遗留代码交互所有的复杂工作。

**优点**

- 减少系统相互依赖。
- 提高灵活性。
- 提高了安全性

**缺点**

- 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

#### 2\. 代理模式（Proxy Pattern）

是为一个对象提供一个代用品或占位符，以便控制对它的访问

> 假设当 A 在心情好的时候收到花，小明表白成功的几率有 60%，而当 A 在心情差的时候收到花，小明表白的成功率无限趋近于 0。 小明跟 A 刚刚认识两天，还无法辨别 A 什么时候心情好。如果不合时宜地把花送给 A，花 被直接扔掉的可能性很大，这束花可是小明吃了 7 天泡面换来的。 但是 A 的朋友 B 却很了解 A，所以小明只管把花交给 B，B 会监听 A 的心情变化，然后选 择 A 心情好的时候把花转交给 A，代码如下：

    let Flower = function() {}
    let xiaoming = {
      sendFlower: function(target) {
        let flower = new Flower()
        target.receiveFlower(flower)
      }
    }
    let B = {
      receiveFlower: function(flower) {
        A.listenGoodMood(function() {
          A.receiveFlower(flower)
        })
      }
    }
    let A = {
      receiveFlower: function(flower) {
        console.log('收到花'+ flower)
      },
      listenGoodMood: function(fn) {
        setTimeout(function() {
          fn()
        }, 1000)
      }
    }
    xiaoming.sendFlower(B)
    复制代码

**场景**

- HTML 元 素事件代理

  <ul id="ul">
    <li>1</li>
    <li>2</li>
    <li>3</li>
  </ul>
  <script>
    let ul = document.querySelector('#ul');
    ul.addEventListener('click', event => {
      console.log(event.target);
    });
  </script>
  复制代码

- ES6 的 proxy [阮一峰 Proxy](https://es6.ruanyifeng.com/#docs/proxy)

- jQuery.proxy()方法

**优点**

- 代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用

- 代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；

**缺点**

- 处理请求速度可能有差别，非直接访问存在开销

#### 3\. 工厂模式（Factory Pattern）

工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。

    class Product {
        constructor(name) {
            this.name = name
        }
        init() {
            console.log('init')
        }
        fun() {
            console.log('fun')
        }
    }

    class Factory {
        create(name) {
            return new Product(name)
        }
    }

    // use
    let factory = new Factory()
    let p = factory.create('p1')
    p.init()
    p.fun()
    复制代码

**场景**

- 如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择

- 将 new 操作简单封装，遇到 new 的时候就应该考虑是否用工厂模式；

- 需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性

**优点**

- 创建对象的过程可能很复杂，但我们只需要关心创建结果。

- 构造函数和创建者分离, 符合“开闭原则”

- 一个调用者想创建一个对象，只要知道其名称就可以了。

- 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。

**缺点**

- 添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度

- 考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度

**什么时候不用**

- 当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。

- 由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。

#### 4\. 单例模式（Singleton Pattern）

顾名思义，单例模式中 Class 的实例个数最多为 1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。

实现单例模式需要解决以下几个问题：

- 如何确定 Class 只有一个实例？

- 如何简便的访问 Class 的唯一实例？

- Class 如何控制实例化的过程？

- 如何将 Class 的实例个数限制为 1？

我们一般通过实现以下两点来解决上述问题：

- 隐藏 Class 的构造函数，避免多次实例化

- 通过暴露一个 getInstance() 方法来创建/获取唯一实例

Javascript 中单例模式可以通过以下方式实现：

    // 单例构造器
    const FooServiceSingleton = (function () {
      // 隐藏的Class的构造函数
      function FooService() {}

      // 未初始化的单例对象
      let fooService;

      return {
        // 创建/获取单例对象的函数
        getInstance: function () {
          if (!fooService) {
            fooService = new FooService();
          }
          return fooService;
        }
      }
    })();
    复制代码

实现的关键点有：

1.  使用 IIFE 创建局部作用域并即时执行；
2.  `getInstance()`为一个 闭包 ，使用闭包保存局部作用域中的单例对象并返回。

我们可以验证下单例对象是否创建成功：

    const fooService1 = FooServiceSingleton.getInstance();
    const fooService2 = FooServiceSingleton.getInstance();

    console.log(fooService1 === fooService2); // true
    复制代码

**场景例子**

- 定义命名空间和实现分支型方法

- 登录框

- vuex 和 redux 中的 store

**优点**

- 划分命名空间，减少全局变量

- 增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护

- 且只会实例化一次。简化了代码的调试和维护

**缺点**

- 由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合
- 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一
- 个单元一起测试。

#### 5\. 策略模式（Strategy Pattern）

策略模式简单描述就是：对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。把它们一个个封装起来，并且使它们可以互相替换

    <html>
    <head>
        <title>策略模式-校验表单</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    </head>
    <body>
        <form id = "registerForm" method="post" action="http://xxxx.com/api/register">
            用户名：<input type="text" name="userName">
            密码：<input type="text" name="password">
            手机号码：<input type="text" name="phoneNumber">
            <button type="submit">提交</button>
        </form>
        <script type="text/javascript">
            // 策略对象
            const strategies = {
              isNoEmpty: function (value, errorMsg) {
                if (value === '') {
                  return errorMsg;
                }
              },
              isNoSpace: function (value, errorMsg) {
                if (value.trim() === '') {
                  return errorMsg;
                }
              },
              minLength: function (value, length, errorMsg) {
                if (value.trim().length < length) {
                  return errorMsg;
                }
              },
              maxLength: function (value, length, errorMsg) {
                if (value.length > length) {
                  return errorMsg;
                }
              },
              isMobile: function (value, errorMsg) {
                if (!/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\d{8}$/.test(value)) {
                  return errorMsg;
                }
              }
            }

            // 验证类
            class Validator {
              constructor() {
                this.cache = []
              }
              add(dom, rules) {
                for(let i = 0, rule; rule = rules[i++];) {
                  let strategyAry = rule.strategy.split(':')
                  let errorMsg = rule.errorMsg
                  this.cache.push(() => {
                    let strategy = strategyAry.shift()
                    strategyAry.unshift(dom.value)
                    strategyAry.push(errorMsg)
                    return strategies[strategy].apply(dom, strategyAry)
                  })
                }
              }
              start() {
                for(let i = 0, validatorFunc; validatorFunc = this.cache[i++];) {
                  let errorMsg = validatorFunc()
                  if (errorMsg) {
                    return errorMsg
                  }
                }
              }
            }

            // 调用代码
            let registerForm = document.getElementById('registerForm')

            let validataFunc = function() {
              let validator = new Validator()
              validator.add(registerForm.userName, [{
                strategy: 'isNoEmpty',
                errorMsg: '用户名不可为空'
              }, {
                strategy: 'isNoSpace',
                errorMsg: '不允许以空白字符命名'
              }, {
                strategy: 'minLength:2',
                errorMsg: '用户名长度不能小于2位'
              }])
              validator.add(registerForm.password, [ {
                strategy: 'minLength:6',
                errorMsg: '密码长度不能小于6位'
              }])
              validator.add(registerForm.phoneNumber, [{
                strategy: 'isMobile',
                errorMsg: '请输入正确的手机号码格式'
              }])
              return validator.start()
            }

            registerForm.onsubmit = function() {
              let errorMsg = validataFunc()
              if (errorMsg) {
                alert(errorMsg)
                return false
              }
            }
        </script>
    </body>
    </html>

    复制代码

**场景例子**

- 如果在一个系统里面有许多类，它们之间的区别仅在于它们的'行为'，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。

- 一个系统需要动态地在几种算法中选择一种。

- 表单验证

**优点**

- 利用组合、委托、多态等技术和思想，可以有效的避免多重条件选择语句

- 提供了对开放-封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，理解，易于扩展

- 利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的代替方案

**缺点**

- 会在程序中增加许多策略类或者策略对象

- 要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点，这样才能选择一个合适的 strategy

#### 6\. 迭代器模式（Iterator Pattern）

如果你看到这，ES6 中的迭代器 Iterator 相信你还是有点印象的，上面第 60 条已经做过简单的介绍。迭代器模式简单的说就是提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。

迭代器模式解决了以下问题：

- 提供一致的遍历各种数据结构的方式，而不用了解数据的内部结构

- 提供遍历容器（集合）的能力而无需改变容器的接口

一个迭代器通常需要实现以下接口：

- hasNext()：判断迭代是否结束，返回 Boolean

- next()：查找并返回下一个元素

为 Javascript 的数组实现一个迭代器可以这么写：

    const item = [1, 'red', false, 3.14];

    function Iterator(items) {
      this.items = items;
      this.index = 0;
    }

    Iterator.prototype = {
      hasNext: function () {
        return this.index < this.items.length;
      },
      next: function () {
        return this.items[this.index++];
      }
    }
    复制代码

验证一下迭代器是否工作：

    const iterator = new Iterator(item);

    while(iterator.hasNext()){
      console.log(iterator.next());
    }
    //输出：1, red, false, 3.14
    复制代码

ES6 提供了更简单的迭代循环语法 for...of，使用该语法的前提是操作对象需要实现 可迭代协议（The iterable protocol），简单说就是该对象有个 Key 为 Symbol.iterator 的方法，该方法返回一个 iterator 对象。

比如我们实现一个 Range 类用于在某个数字区间进行迭代：

    function Range(start, end) {
      return {
        [Symbol.iterator]: function () {
          return {
            next() {
              if (start < end) {
                return { value: start++, done: false };
              }
              return { done: true, value: end };
            }
          }
        }
      }
    }

    复制代码

验证一下：

    for (num of Range(1, 5)) {
      console.log(num);
    }
    // 输出：1, 2, 3, 4
    复制代码

#### 7\. 观察者模式（Observer Pattern）

**观察者模式**又称**发布-订阅模式**（Publish/Subscribe Pattern），是我们经常接触到的设计模式，日常生活中的应用也比比皆是，比如你订阅了某个博主的频道，当有内容更新时会收到推送；又比如 JavaScript 中的事件订阅响应机制。观察者模式的思想用一句话描述就是：**被观察对象（subject）维护一组观察者（observer），当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者**。

观察者模式中 Subject 对象一般需要实现以下 API：

- subscribe(): 接收一个观察者 observer 对象，使其订阅自己

- unsubscribe(): 接收一个观察者 observer 对象，使其取消订阅自己

- fire(): 触发事件，通知到所有观察者

用 JavaScript 手动实现观察者模式：

    // 被观察者
    function Subject() {
      this.observers = [];
    }

    Subject.prototype = {
      // 订阅
      subscribe: function (observer) {
        this.observers.push(observer);
      },
      // 取消订阅
      unsubscribe: function (observerToRemove) {
        this.observers = this.observers.filter(observer => {
          return observer !== observerToRemove;
        })
      },
      // 事件触发
      fire: function () {
        this.observers.forEach(observer => {
          observer.call();
        });
      }
    }
    复制代码

验证一下订阅是否成功：

    const subject = new Subject();

    function observer1() {
      console.log('Observer 1 Firing!');
    }


    function observer2() {
      console.log('Observer 2 Firing!');
    }

    subject.subscribe(observer1);
    subject.subscribe(observer2);
    subject.fire();

    //输出：
    Observer 1 Firing!
    Observer 2 Firing!
    复制代码

验证一下取消订阅是否成功：

    subject.unsubscribe(observer2);
    subject.fire();

    //输出：
    Observer 1 Firing!
    复制代码

**场景**

- DOM 事件

  document.body.addEventListener('click', function() {
  console.log('hello world!');
  });
  document.body.click()
  复制代码

- vue 响应式

**优点**

- 支持简单的广播通信，自动通知所有已经订阅过的对象

- 目标对象与观察者之间的抽象耦合关系能单独扩展以及重用

- 增加了灵活性

- 观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。

**缺点**

- 过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解

#### 8\. 中介者模式（Mediator Pattern）

在中介者模式中，中介者（Mediator）包装了一系列对象相互作用的方式，使得这些对象不必直接相互作用，而是由中介者协调它们之间的交互，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。

中介者模式和观察者模式有一定的相似性，都是一对多的关系，也都是集中式通信，不同的是中介者模式是处理同级对象之间的交互，而观察者模式是处理 Observer 和 Subject 之间的交互。中介者模式有些像婚恋中介，相亲对象刚开始并不能直接交流，而是要通过中介去筛选匹配再决定谁和谁见面。

**场景**

- 例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发 change 事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。

  var goods = { //手机库存
  'red|32G': 3,
  'red|64G': 1,
  'blue|32G': 7,
  'blue|32G': 6,
  };
  //中介者
  var mediator = (function() {
  var colorSelect = document.getElementById('colorSelect');
  var memorySelect = document.getElementById('memorySelect');
  var numSelect = document.getElementById('numSelect');
  return {
  changed: function(obj) {
  switch(obj){
  case colorSelect:
  //TODO
  break;
  case memorySelect:
  //TODO
  break;
  case numSelect:
  //TODO
  break;
  }
  }
  }
  })();
  colorSelect.onchange = function() {
  mediator.changed(this);
  };
  memorySelect.onchange = function() {
  mediator.changed(this);
  };
  numSelect.onchange = function() {
  mediator.changed(this);
  };
  复制代码

- 聊天室里

聊天室成员类：

    function Member(name) {
      this.name = name;
      this.chatroom = null;
    }

    Member.prototype = {
      // 发送消息
      send: function (message, toMember) {
        this.chatroom.send(message, this, toMember);
      },
      // 接收消息
      receive: function (message, fromMember) {
        console.log(`${fromMember.name} to ${this.name}: ${message}`);
      }
    }
    复制代码

聊天室类：

    function Chatroom() {
      this.members = {};
    }

    Chatroom.prototype = {
      // 增加成员
      addMember: function (member) {
        this.members[member.name] = member;
        member.chatroom = this;
      },
      // 发送消息
      send: function (message, fromMember, toMember) {
        toMember.receive(message, fromMember);
      }
    }
    复制代码

测试一下：

    const chatroom = new Chatroom();
    const bruce = new Member('bruce');
    const frank = new Member('frank');

    chatroom.addMember(bruce);
    chatroom.addMember(frank);

    bruce.send('Hey frank', frank);

    //输出：bruce to frank: hello frank
    复制代码

**优点**

- 使各对象之间耦合松散，而且可以独立地改变它们之间的交互

- 中介者和对象一对多的关系取代了对象之间的网状多对多的关系

- 如果对象之间的复杂耦合度导致维护很困难，而且耦合度随项目变化增速很快，就需要中介者重构代码

**缺点**

- 系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介 者对象自身往往就是一个难以维护的对象。

#### 9\. 访问者模式（Visitor Pattern）

**访问者模式** 是一种将算法与对象结构分离的设计模式，通俗点讲就是：访问者模式让我们能够在不改变一个对象结构的前提下能够给该对象增加新的逻辑，新增的逻辑保存在一个独立的访问者对象中。访问者模式常用于拓展一些第三方的库和工具。

    // 访问者
    class Visitor {
        constructor() {}
        visitConcreteElement(ConcreteElement) {
            ConcreteElement.operation()
        }
    }
    // 元素类
    class ConcreteElement{
        constructor() {
        }
        operation() {
           console.log("ConcreteElement.operation invoked");
        }
        accept(visitor) {
            visitor.visitConcreteElement(this)
        }
    }
    // client
    let visitor = new Visitor()
    let element = new ConcreteElement()
    elementA.accept(visitor)
    复制代码

访问者模式的实现有以下几个要素：

- Visitor Object：访问者对象，拥有一个`visit()`方法

- Receiving Object：接收对象，拥有一个`accept()` 方法

- visit(receivingObj)：用于 Visitor 接收一个`Receiving Object`

- accept(visitor)：用于`Receving Object`接收一个 Visitor，并通过调用`Visitor`的 `visit()` 为其提供获取`Receiving Object`数据的能力

简单的代码实现如下：

    Receiving Object：

    function Employee(name, salary) {
      this.name = name;
      this.salary = salary;
    }

    Employee.prototype = {
      getSalary: function () {
        return this.salary;
      },
      setSalary: function (salary) {
        this.salary = salary;
      },
      accept: function (visitor) {
        visitor.visit(this);
      }
    }
    Visitor Object：

    function Visitor() { }

    Visitor.prototype = {
      visit: function (employee) {
        employee.setSalary(employee.getSalary() * 2);
      }
    }
    复制代码

验证一下：

    const employee = new Employee('bruce', 1000);
    const visitor = new Visitor();
    employee.accept(visitor);

    console.log(employee.getSalary());//输出：2000
    复制代码

**场景**

- 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作

- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类。

**优点**

- 符合单一职责原则

- 优秀的扩展性

- 灵活性

**缺点**

- 具体元素对访问者公布细节，违反了迪米特原则

- 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。

- 具体元素变更比较困难

相关参考资料：

[JavaScript 设计模式 es6（23 种)](https://juejin.im/post/5e021eb96fb9a01628014095)

[《前端面试之道》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc74186fb9a049ab0d0b6b)

[《JavaScript 设计模式》](https://juejin.im/post/59df4f74f265da430f311909#heading-3)

[《JavaScript 中常见设计模式整理》](https://juejin.im/post/5afe6430518825428630bc4d)

### 💕 看完三件事:

1.  点赞 | 你可以`点击——>收藏——>退出`一气呵成，但别忘了点赞 🤭
2.  关注 | 点个关注，下次不迷路 😘
3.  也可以到[GitHub](https://github.com/JakeZhangZJK/myBlog)拿我所有文章源文件 🤗

### 后话

以上 66 条便是这几天复盘的总结，整体上是按照由浅入深的顺序来的，小部分内容并非原创，相关的参考我都有在每条的末尾贴了链接，在这里要特别感谢各路大佬的博客，给了我很多帮助~

前端是个大杂烩，各种框架层出不穷，但万变不离 JS，务实基础才是根本，如果你觉得本文对你有所帮助，点个赞支持一下吧~### 1.🤨 标准的 CSS 盒子模型及其和低版本的 IE 盒子模型的区别？

标准（W3C）盒子模型：`width` = 内容宽度`（content） + border + padding + margin`

低版本 IE 盒子模型： `width` = 内容宽度`（content + border + padding）+ margin`

图片展示:

![](https://user-gold-cdn.xitu.io/2020/5/30/172633c783abc1eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

![](https://user-gold-cdn.xitu.io/2020/5/30/17263443113eb879?imageslim)

区别： 标准盒子模型盒子的`height`和`width`是`content`（内容）的宽高，而 IE 盒子模型盒子的宽高则包括`content+padding+border`部分。

### 2.几种解决 IE6 存在的 bug 的方法

- 由`float`引起的双边距的问题，使用`display`解决；
- 由`float`引起的 3 像素问题，使用`display: inline -3px`;
- 使用正确的书写顺序`link visited hover active`，解决超链接`hover`点击失效问题；
- 对于`IE` 的`z-index`问题，通过给父元素增加`position: relative`解决；
- 使用`!important`解决`Min-height`最小高度问题；
- 使用`iframe`解决`select`在`IE6`下的覆盖问题；
- 使用`over: hidden`, `zoom: 0.08`, `line-height: 1px`解决定义 1px 左右的容器宽度问题；

🍀**注意**：有关`IE6`支不支持`!important`的问题，对于单个类是支持的。例如：

    .content { color: pink !importent };
    .content { color: orange };
    // 这里IE6及以上，FF，google等都将显示粉红色
    复制代码

但是，当一个样式内部有多个相同属性的时候。例如：

    .content { color: pink !importent; color: orange };
    // IE7及以上，FF, google显示粉红色，而IE6将显示橙色（原因是一个样式内重复设置了属性，后面的就会覆盖掉之前的）
    复制代码

### 3.CSS 选择符有哪些？哪些属性可以继承？

常见的选择符有一下：

`id`选择器（`#content`），类选择器（`.content`）, 标签选择器（`div`, `p`, `span`等）, 相邻选择器（`h1+p`）, 子选择器（`ul>li`）, 后代选择器（`li a`）， 通配符选择器（`*`）, 属性选择器（`a[rel = "external"]`）， 伪类选择器（`a:hover`, `li:nth-child`）

可继承的样式属性： `font-size`, `font-family`, `color`, `ul`, `li`, `dl`, `dd`, `dt`;

不可继承的样式属性： `border`, `padding`, `margin`, `width`, `height`；

### 4.CSS 优先级算法如何计算？

- 考虑到就近原则，同权重情况下样式定义以最近者为准
- 载入的样式按照最后的定位为准

优先级排序：

同权重情况下： 内联样式表（标签内部）> 嵌入样式表（当前文件中）\> 外部样式表（外部文件中）

`!important > # > . > tag`

🍀**注意**： `!important` 比 内联优先级高

### 5.CSS3 新增伪类有那些？

- `:root` 选择文档的根元素，等同于`html`元素

- `:empty` 选择没有子元素的元素

- `:target` 选取当前活动的目标元素

- `:not(selector)` 选择除 `selector` 元素意外的元素

- `:enabled` 选择可用的表单元素

- `:disabled` 选择禁用的表单元素

- `:checked` 选择被选中的表单元素

- `:nth-child(n)` 匹配父元素下指定子元素，在所有子元素中排序第`n`

- `nth-last-child(n)` 匹配父元素下指定子元素，在所有子元素中排序第`n`，从后向前数

- `:nth-child(odd)`

- `:nth-child(even)`

- `:nth-child(3n+1)`

- `:first-child`

- `:last-child`

- `:only-child`

- `:nth-of-type(n)` 匹配父元素下指定子元素，在同类子元素中排序第`n`

- `:nth-last-of-type(n)` 匹配父元素下指定子元素，在同类子元素中排序第`n`，从后向前数

- `:nth-of-type(odd)`

- `:nth-of-type(even)`

- `:nth-of-type(3n+1)`

- `:first-of-type`

- `:last-of-type`

- `:only-of-type`

- `::selection` 选择被用户选取的元素部分（伪元素）

- `:first-line` 选择元素中的第一行（伪元素）

- `:first-letter` 选择元素中的第一个字符（伪元素）

- `:after` 在元素在该元素之后添加内容（伪元素）

- `:before` 在元素在该元素之前添加内容（伪元素）

### 6.如何居中 div？如何居中一个浮动元素？如何让绝对定位的 div 居中？

#### 水平居中

    // 方式1： 使用margin： 0 auto居中
    css:
        * {margin: 0; padding: 0;}
        .content {
            margin: 0 auto;
        	width: 100px;
        	height: 100px;
            background: pink;
        }

    // 方式2： 使用 定位 + left 居中

    css:
        * {margin: 0; padding: 0;}
        .content {
        	width: 100px;
        	height: 100px;
            background: pink;
            position： relative；
            left： 50%；
            margin-left: -50px;
        }

    html:
       <div class="content"></div>
    复制代码

#### 垂直居中

    css:
        * {margin: 0; padding: 0;}
        .content {
        	width: 100px;
        	height: 100px;
            background: pink;
            position: absolute;
            top:50%;
            left: 50%;
            transform: translate(-50%, -50%);    //  更新： 此处感谢小伙伴留言指出
        }

    html:
        <div class="content"></div>
    复制代码

#### 居中浮动元素

    css:
        * {margin: 0; padding: 0;}
        .content {
        	width: 600px;
        	height: 600px;
            border: 1px solid green;
        }
        .left: {
            height:100px;
            width: 100px;
            background-color: pink;
            margin-left: 50%;   // 水平居中
            position: relative;
            left: -50px;
        }

    html:
        <div class="content">
            <div class="left"> </div>
        </div>
    复制代码

#### 如何让绝对定位的 div 居中

    css:
        * {margin: 0; padding: 0;}
        .content {
            margin: 0 auto;
            position: absolute;
            width: 1500px;
            background: pink;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
        }

    html:
        <div class="content"></div>
    复制代码

### 7.display 有哪些值？他们的作用是什么？

值

作用

none

使用后元素将不会显示

grid

定义一个容器属性为网格布局

flex

定义一个弹性布局

block

使用后元素将变为块级元素显示，元素前后带有换行符

inline

display 默认值。使用后原色变为行内元素显示，前后无换行符

list-item

使用后元素作为列表显示

run-in

使用后元素会根据上下文作为块级元素或行内元素显示

table

使用后将作为块级表格来显示（类似`<table>`），前后带有换行符

inline-table

使用后元素将作为内联表格显示（类似`<table>`），前后没有换行符

table-row-group

元素将作为一个或多个行的分组来显示（类似`<tbody>`）

table-hewder-group

元素将作为一个或多个行的分组来表示（类似`<thead>`）

table-footer-group

元素将作为一个或多个行分组显示（类似`<tfoot>`）

table-row

元素将作为一个表格行显示（类似`<tr>`）

table-column-group

元素将作为一个或多个列的分组显示（类似`<colgroup>`）

table-column

元素将作为一个单元格列显示（类似`<col>`）

table-cell

元素将作为一个表格单元格显示（类似`<td>和<th>`）

table-caption

元素将作为一个表格标题显示（类似`<caption>`）

inherit

规定应该从父元素集成 display 属性的值

其中，常用的有：`block`， `inline-block`， `none`， `table`， `line`。

### 8.position 的值 relative 和 absolute 定位原点？

首先，使用`position`的时候，应该记住一个规律是‘**子绝父相**’。

`relative`（相对定位）： 生成相对定位的元素，定位原点是元素本身所在的位置；

`absolute`（绝对定位）：生成绝对定位的元素，定位原点是离自己这一级元素最近的一级`position`设置为`absolute`或者`relative`的父元素的左上角为原点的。

`fixed` （老 IE 不支持）：生成绝对定位的元素，相对于浏览器窗口进行定位。

`static`：默认值。没有定位，元素出现在正常的流中（忽略 `top`, `bottom`, `left`, `right`、`z-index` 声明）。

`inherit`：规定从父元素继承 `position` 属性的值。

**更新一个属性**

`sticky`: (新增元素，目前兼容性可能不是那么的好)，可以设置 position:sticky 同时给一个 (top,bottom,right,left) 之一即可。

**注意**：

- 使用`sticky`时，必须指定 top、bottom、left、right4 个值之一，不然只会处于相对定位；
- `sticky`只在其父元素内其效果，且保证父元素的高度要高于`sticky`的高度；
- 父元素不能`overflow:hidden`或者`overflow:auto`等属性。

### 9.CSS3 有哪些新特性？

关于`CSS`新增的特性，有以下：

- 选择器;
- 圆角`（border-raduis）`;
- 多列布局`（multi-column layout）`;
- 阴影`（shadow）`和反射`（reflect）`;
- 文字特效`（text-shadow）`;
- 文字渲染`（text-decoration`）;
- 线性渐变`（gradient）`;
- 旋转`（rotate`）/缩放`（scale）`/倾斜`（skew）`/移动`（translate）`;
- 媒体查询`（@media）`;
- `RGBA`和透明度 ;
- `@font-face`属性;
- 多背景图 ;
- 盒子大小;
- 语音;

大致想到这么多，有遗漏的可以留言指出，小编看到会加上。

### 10.用纯 CSS 创建一个三角形的原理是什么？

#### 方法一：隐藏上，左，右三条边，颜色设定为（transparent）

    css:
        * {margin: 0; padding: 0;}
        .content {
            width: 0;
            height: 0;
            margin: 0 auto;
            border-width: 20px;
            border-style: solid;
            border-color: transparent transparent pink transparent;  // 对应上右下左，此处为 下 粉色
        }

    html:
        <div class="content"></div>
    复制代码

#### 方法二： 采用的是均分原理

实现步骤： 1.首先保证元素是块级元素；2.设置元素的边框；3.不需要显示的边框使用透明色。

    css:
        * {margin: 0; padding: 0;}
        .content {
            width:0;
            height:0;
            margin:0 auto;
            border:50px solid transparent;
            border-top: 50px solid pink;
        }

    html:
        <div class="content"></div>
    复制代码

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="474" height="89"></svg>)

---

### 11.🤨 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？

响应式网站设计`（Responsive Web design`）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。

关于原理： 基本原理是通过媒体查询`（@media）`查询检测不同的设备屏幕尺寸做处理。

关于兼容： 页面头部必须有 mate 声明的`viewport`。

    <meta name="’viewport’" content="”width=device-width," initial-scale="1." maximum-scale="1,user-scalable=no”"/>
    复制代码

### 12.为什么要初始化 CSS 样式？

因为浏览器的兼容问题，不同浏览器对标签的默认值是不同的，如果没有对浏览器的`CSS`初始化，会造成相同页面在不同浏览器的显示存在差异。

### 13.浮动原理以及为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？

非 IE 浏览器下，容器不设定高度且子元素浮动时，容器高度不能被内容撑开。此时，内容会溢出到容器外面而影响布局。此类现象被称为浮动（溢出）。

原理：

- 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）；
- 浮动元素碰到包含它的边框或其他浮动元素的边框停留。

浮动元素碰到包含他的边框或者浮动元素的边框停留。由于浮动元素不在文档流之中，文档流的块级框会表现的就像浮动框不存在一样。浮动元素会漂浮在文档流的块级框之上。

浮动会带来的问题：

- 父级元素的高度将会无法被撑开，会影响与父级元素同级的元素
- 与浮动元素同级的非浮动元素（内联元素）会跟随其后
- 若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构

清除方式：

- 父级盒子定义高度`（height）`;
- 最后一个浮动元素后面加一个`div`空标签，并且添加样式`clear: both`;
- 包含浮动元素的父级标签添加样式`overflow`为`hidden/both`;
- 父级`div`定义`zoom`;

### 14.CSS 优化、提高性能的方法有哪些？

- 多个`css`可合并，并尽量减少`http`请求
- 属性值为 0 时，不加单位
- 将`css`文件放在页面最上面
- 避免后代选择符，过度约束和链式选择符
- 使用紧凑的语法
- 避免不必要的重复
- 使用语义化命名，便于维护
- 尽量少的使用`!impotrant`，可以选择其他选择器
- 精简规则，尽可能合并不同类的重复规则
- 遵守盒子模型规则

### 15.CSS 预处理器/后处理器是什么？为什么要使用它们？

预处理器，如：`less`，`sass`，`stylus`,用来预编译`sass`或者`less`，增加了`css`代码的复用性，还有层级，`mixin`， 变量，循环， 函数等，对编写以及开发 UI 组件都极为方便。

后处理器， 如： `postCss`,通常被视为在完成的样式表中根据`css`规范处理`css`，让其更加有效。目前最常做的是给`css`属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。

`css`预处理器为`css`增加一些编程特性，无需考虑浏览器的兼容问题，我们可以在`CSS`中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让我们的`css`更加的简洁，增加适应性以及可读性，可维护性等。

其它`css`预处理器语言：`Sass（Scss`）, `Less`, `Stylus`, `Turbine`, `Swithch css`, `CSS Cacheer`, `DT Css`。

使用原因：

- 结构清晰， 便于扩展
- 可以很方便的屏蔽浏览器私有语法的差异
- 可以轻松实现多重继承
- 完美的兼容了`CSS`代码，可以应用到老项目中

### 16.::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用

（1）、冒号(`:`)用于`CSS3`伪类，双冒号(`::`)用于`CSS3`伪元素。

（2）、`::before`就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于`dom`之中，只存在在页面之中。

🍀**注意：** `:before`和 `:after` 这两个伪元素，是在`CSS2.1`里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着`Web`的进化，在`CSS3`的规范里，伪元素的语法被修改成使用双冒号，成为`::before ::after`。

### 17.让页面里的字体变清晰，变细用 CSS 怎么做？

`-webkit-font-smoothing`在 `window`系统下没有起作用，但是在 `IOS`设备上起作用 `-webkit-font-smoothing：antialiased`是最佳的，灰度平滑。

### 18\. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？

多数显示器默认频率是`60Hz`，即 1 秒刷新 60 次，所以理论上最小间隔为`1/60＊1000ms ＝ 16.7ms`。

### 19\. rgba() 和 opacity 的透明效果有什么不同？

`opacity` 作用于元素以及元素内的所有内容（包括文字）的透明度；

`rgba()`只作用于元素自身的颜色或其背景色，子元素不会继承透明效果；

### 20.css 属性 content 有什么作用？

`content` 属性专门应用在 `before/after` 伪元素上，用于插入额外内容或样式。

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="474" height="89"></svg>)

---

### 21.🧐 请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？

> 概念： `Flex`是`Flexible Box`的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。采用`Flex`布局的元素，称为`Flex`容器`（flex container）`，简称”容器”。它的所有子元素自动成为容器成员，称为`Flex`项目`（flex item）`，简称”项目”。

适用场景： 任何一个容器都可以指定为`Flex`布局。`Flexbox` 用于不同尺寸屏幕中创建可自动扩展和收缩布局。

### 22.display:inline-block 什么时候会显示间隙？

- 有空格时候会有间隙， 可以删除空格解决；
- `margin`正值的时候， 可以让`margin`使用负值解决；
- 使用`font-size`时候，可通过设置`font-size:0`、`letter-spacing`、`word-spacing`解决；

### 23\. png、jpg、 jpeg、 bmp、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？

（1）、`png`-便携式网络图片`（Portable Network Graphics）`,是一种无损数据压缩位图文件格式。优点是：压缩比高，色彩好。 大多数地方都可以用。

（2）、`jpg`是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在`www`上，被用来储存和传输照片的格式。

（3）、`gif`是一种位图文件格式，以 8 位色重现真色彩的图像。可以实现动画效果。

（4）、`bmp`的优点： 高质量图片；缺点： 体积太大； 适用场景： `windows`桌面壁纸；

（4）、`webp`格式是谷歌在 2010 年推出的图片格式，压缩率只有`jpg`的 2/3，大小比`png`小了 45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和`opera`支持。

### 24\. 在 CSS 样式中常使用 px、em 在表现上有什么区别？

`px`相对于显示器屏幕分辨率，无法用浏览器字体放大功能。

`em`值不是固定的，会继承父级的字体大小： `em = 像素值 / 父级font-size`。

### 25.一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度问题怎么解决？

方案一： `.content { height: calc(100%-100px); }`

方案二：`.container { position:relative; } .content { position: absolute; top: 100px; bottom: 0; }`

方案三：`.container { display:flex; flex-direction:column; } .content { flex:1; }`

### 26.overflow: scroll 时不能平滑滚动的问题怎么处理？

监听滚轮事件，然后滚动到一定距离时用 `jquery` 的 `animate` 实现平滑效果。

### 27.transform、animation 和 animation-duration 的区别？

- `Transform`: 它和`width`、`left`一样，定义了元素很多静态样式实现变形、旋转、缩放、移位及透视等功能，通过一系列功能的组合我们可以实现很炫酷的静态效果（非动画)。
- `Animation`: 作用于元素本身而不是样式属性,属于关键帧动画的范畴，它本身被用来替代一些纯粹表现的`javascript`代码而实现动画,可以通过`keyframe`显式控制当前帧的属性值。
- `animation-duration`：规定完成动画所花费的时间，以秒或毫秒计。

### 28.对 line-height 是如何理解的？

`line-height`指的是一行字的高度，包含了字间距，实际上是下一行基线到上一行基线的距离。如果一个标签没有定义`height`属性，那么其最终表现的高度是由`line-height`决定的。一个容器没有设置高度，那么撑开容器的高度的是`line-height`,而不是容器内部的文字内容。把`line-height`值设置为`height`一样大小的值可以实现单行文字的垂直居中。`line-height`和`height`都能撑开一个高度，`height`会触发`haslayout`，而`line-height`不会。

### 29.抽离样式模块怎么写？述其思路。

可将`css`拆分成两部分： 公共`CSS`和业务`CSS`。

网站的配色，字体，交互提取出为公共的`CSS`。这部分的`CSS`命名不应涉及具体的业务。对于业务`CSS`，需要有统一的命名，使用公共的前缀。

### 30.在网页中的应该使用奇数还是偶数的字体？

在网页中的应该使用“偶数”字体：

偶数字号相对更容易和 `web` 设计的其他部分构成比例关系，使用奇数号字体时文本段落无法对齐，宋体的中文网页排布中使用最多的就是 `12` 和 `14`。

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="474" height="89"></svg>)

---

### 31\. 🤥 什么是外边距重叠？ 重叠的结果是什么？

首先，外边距重叠就是 `margin-collapse`。相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。 这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距。

折叠结果遵循下列计算原则：

- 两个相邻的外面边距是正数时，折叠结果就是他们之中的较大值；
- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值；
- 两个外边距一正一负时，折叠结果是两者的相加的和；

### 32.display: none; 与 visibility: hidden; 有什么区别？

联系： 这两个属性的值都可以让元素变得不可见；

区别：

- **从占据空间角度看**：`display: none;`会让元素完全从渲染树中消失，渲染的时候不占据任何空间；`visibility: hidden;`不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见；
- **从继承方面角度看**：`display: none;`是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；`visibility:hidden;`是继承属性，子孙节点消失由于继承了`hidden`，通过设置`visibility: visible;`可以让子孙节点显式；
- **从重绘和重排角度看**：修改常规流中元素的`display`通常会造成文档重排。修改`visibility`属性只会造成本元素的重绘 读屏器不会读取`display: none;`元素内容；会读取`visibility: hidden`元素内容；

### 33.css hack 原理及常用 hack 有哪些？

原理： 利用不同浏览器对`CSS`的支持和解析结果不一样编写针对特定浏览器的样式。

常见的`hack`有： **属性 hack**、**选择器 hack**、**IE 条件注释**。

### 34.link 与 @import 的区别？

- `link` 是`HTML`方式， `@import` 是`CSS`方式；
- `link`最大限度支持并行下载，`@import` 过多嵌套导致串行下载，出现`FOUC`；
- `link` 可以通过 `rel="alternate stylesheet"`指定候选样式；
- 浏览器对 `link` 支持早于`@import`，可以使用 `@import`对老浏览器隐藏样式；
- `@import`必须在样式规则之前，可以在 css 文件中引用其他文件；

总的来说： `link`优于`@import`。

### 35.什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？

当使用`@import`导入`CSS`时，会导致某些页面在`IE`出现奇怪的现象： 没有样式的页面内容显示瞬间闪烁，这种现象被称为“文档样式暂时失效”，简称`FOUC`。

产生原因： 当样式表晚于结构性 html 加载时，加载到此样式表时，页面将会停止之前的渲染。等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。

解决办法： 只要在`<head>`之间加入一个`<link>`或者` <script>``</script> `元素即可。

### 36.display,float,position 有什么关系？

- 如果 `display` 为`none`，那么`position`和`float`都不起作用，元素不显示；
- 如果`position`值为`absolute`或者`fixed`，元素绝对定位，`float`的计算值为`none`，`display`根据下面的表格进行调整；
- 如果`float`不是`none`，框是浮动的，`display`根据下表进行调整；
- 其他情况下`display`的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 `display`；

### 37.外边距折叠(collapsing margins)

毗邻的两个或多个`margin`会合并成一个`margin`，叫做外边距折叠。规则如下：

- 两个或多个毗邻的普通流中的块元素垂直方向上的`margin`会折叠；
- 浮动元素或`linline-block`元素或绝对定位元素的`margin`不会和垂直方向上的其他元素的`margin`折叠；
- 创建了会计格式化上下文的元素，不会和它的子元素发生`margin`折叠；
- 元素自身的`margin-bottom`和`margin-top`相邻时也会折叠；

### 38.有哪几种隐藏元素的方法？

- `visibility: hidden;` 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；
- ` opacity: 0;``CSS3 `属性，设置 0 可以使一个元素完全透明；
- `position: absolute;` 设置一个很大的 left 负值定位，使元素定位在可见区域之外；
- `display: none;` 元素会变得不可见，并且不会再占用文档的空间；
- `transform: scale(0);` 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；
- `<div hidden="hidden">` `HTML5`属性,效果和`display:none;`相同，但这个属性用于记录一个元素的状态；
- `height: 0;` 将元素高度设为 0 ，并消除边框；
- `filter: blur(0);` `CSS3`属性，括号内的数值越大，图像高斯模糊的程度越大，到达一定程度可使图像消失`（此处感谢小伙伴支持）`；

### 39.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？

`li`排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔。解决办法：

- 在`ul`中用`font-size：0`（谷歌不支持）；可以使用`letter-space：-3px;`
- 设置`float：left；`

### 40.浏览器是怎样解析 CSS 选择器的？

浏览器解析`CSS`是从上到下，从右到左解析的，这样会提高查找选择器所对应的元素的效率（至于原因，有兴趣的童鞋可以自行去了解）。

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="474" height="89"></svg>)

---

### 41.🤭 全屏滚动的原理是什么？用到了 CSS 的哪些属性？

全屏滚动有点类似于轮播，整体的元素一直排列下去，假设有`5`个需要展示的全屏页面，那么高度是`500%`，只是展示`100%`。也可以理解为超出隐藏部分，滚动时显示。

可能用到的`CSS`属： `overflow:hidden; transform:translate(100%, 100%); display:none;`

❤️**拓展** ： 也可以利用全屏视觉滚动差，使用`background-attachment: fixed;`来实现全屏效果。（这里是细心的小伙伴提出的另一个 idea🤨）

### 42.对浏览器内核的理解？

浏览器内核主要分为两个部分： 渲染引擎和 js 引擎；

- 渲染引擎： 负责取得页面的内容（`html`，`xml`， 图像等）、整理讯息（加入`css`等）、以及计算网页的显示方式，然后对输出至显示器或者打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户以及其他所需要编辑、显示网络的应用程序都需要内核。
- `JS`引擎： 解析和执行`Javascript`来实现网页的动态效果。

最开始渲染引擎和`js`引擎没有明确的区分，后来`js`引擎越来越独立，内核就倾向于只渲染引擎。

### 43.对 WEB 标准以及 W3C 的理解与认识

对于结构的要求：（规范的标签可以提高搜索引擎对页面的抓取效率，对`SEO`很有帮助）

- 标签要闭合
- 标签字母小写
- 标签不允许随意嵌套

对于`CSS`和`JS`来说：

- 尽量使用外链`CSS`样式表和`JS`脚本。同时结构，表现和行为分为三块，符合规范。此外，还得提高页面渲染速度，提高用户体验。
- 尽量少用行内样式，保证结构和表现分离。标签的`id`和`class`等的属性命名要做到见文知意，标签越少，加载越快，用户体验就会越高。同时代码方面也会更易于维护，便于改版。
- 不需要变动内容，便可一同打印版本而不需要复制内容，提高网站易用性。

### 44.制作一个访问量很大的网站，如何管理所有的 css 文件，js 和图片？

从人手，分工和同步方面回答：

- 前期团队必须确认好全局样式，编码模式；
- 代码风格，编写习惯保持一致；
- 标注样式编写人，各模块都要及时标注（标注关键样式调用的地方）；
- 对自己负责的页面进行标注；
- `CSS`和`JS`分文件夹存并行存放，命名都要统一；
- `JS`分文件夹存放，明明以该`JS`功能为准的英文翻译；
- 图片采用整合的`.png`格式存放，金狼整合在一起，方便将来管理；

### 45.视差滚动效果以及如何实现？

视差滚动`（Parallax Scrolling）`指网页滚动过程中，多层次的元素进行不同程度的移动，视觉上形成立体运动效果的网页展示技术（3D 效果）。

实现方式：

- `CSS3`实现： 优点是开发时间相对较短，性能和开发效率比较好。缺点是不能兼容到低版本的浏览器；
- `JQuery`实现：（通过控制不同层滚动速度，计算每一层的时间）优点是能兼容到各个版本，效果可控性好，缺点是开发起来对制作者的要求较高；
- 插件实现方式： 例如使用`parallax-scrolling`,兼容性十分好；

### 46.对 BFC 规范(块级格式化上下文：block formatting context)的理解

`BFC`规定了内部的`Block Box`如何布局。一个页面是由很多个`Box`组成的，元素的类型和`display`属性，决定了这个`Box`的类型。不同类型的`box`，会参与不同的`Formatting Context`（决定如何渲染文档的容器），因此`Box`内的元素会以不用的方式渲染，也是就是说`BFC`内部的元素和外部的元素不会相互影响。

定位方案：

- 内部的`box`会在垂直方向上一个接一个的放置；
- `box`垂直方向的距离由`margin`决定，属于同一个`BFC`的两个相邻`Box`的`margin`会发生重叠；
- 每个元素`margin box`的左边，与包含块`border box`的左边相接触；
- `BFC`的区域不会与 float box 重叠；
- `BFC`是页面上的一个隔离的独立容器，容器里面的元素不会影响到外面的元素；
- 计算`BFC`的高度时，浮动元素也会参与计算。

满足下列条件之一就可以出发 BFC：

- 根元素变化，即`html`；
- `float`的值不为`none`（默认）；
- `overflow`的值不为`visible`（默认）；
- `display`的值为`inline-block`, `tabke-cell`，`table-caption`；
- `position`的值为`absolute`或`fixed`;

### 47.元素竖向的百分比设定是相对于容器的高度吗？

一般来说，子元素的百分比单位都是以父元素为依据。但是`margin`和`padding`例外。元素的`height`是相对于容器的高度，但是元素的`margin`和`padding`是相对于容器的宽度。

### 48.一个满屏'品字'布局如何设计?

方法有挺多种，但是比较简单的方式就是： 上面的`div`宽度设置为 100%，底下两个`div`设置成`50%`，并使用`float`或者`inline`使其保持在同一行即可（具体的样式可以自己微调）。如下：

    css:
    .content {
        width: 50%;
        height: 150px;
        margin: 0 auto;
    }
    .top {
        width: 40%;
        height: 50px;
        background-color: pink;
        margin-bottom: 50px;
        margin-left: 30%;
    }
    .left {
        width: 45%;
        height: 50px;
        background-color: pink;
        float: left;
    }
    .right {
        width: 45%;
        height: 50px;
        background-color: pink;
        float: right;
    }

    html:
    <div class="content">
        <div class="top"></div>
        <div class="left"></div>
        <div class="right"></div>
    </div>>
    复制代码

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="720" height="176"></svg>)

### 49.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧 ？

（1）、问题：`png24`位的图片在`ie`浏览器上出现背景。解决： 做成`png8`；

（2）、问题：浏览器默认的`margin`和`padding`不同。 解决： 添加一个全局的`*{ margin： 0; padding： 0;}`；

（3）、问题：`IE`下,可以使用获取常规属性的方法来获取自定义属性,也可以使用`getAttribute()`获取自定义属性，而`Firefox`下,只能使用`getAttribute()`获取自定义属性。 解决： 统一通过`getAttribute()`获取自定义属性；

（4）、问题： `IE`下,`event`对象有`x`,`y`属性,但是没有`pageX`,`pageY`属性，而`Firefox`下,`event`对象有`pageX`,`pageY`属性,但是没有`x`,`y`属性。 解决： 使用`mX(mX = event.x ? event.x : event.pageX;)`来代替`IE`下的`event.x`或者`Firefox`下的`event.pageX`。

### 50.box-sizing 常用的属性有哪些？分别有什么作用？

- `box-sizing: content-box;` // 默认的标准`(W3C)`盒模型元素效果；
- `box-sizing: border-box;` // 触发怪异`(IE)`盒模型元素的效果；
- `box-sizing: inherit;` // 继承父元素 `box-sizing` 属性的值；

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="474" height="89"></svg>)

---

### 51\. 🤤 在网页中的应该使用奇数还是偶数的字体？

一般情况下，在网页中，应该使用 **偶数** 字体。原因：

- 偶数字号相对更容易和`web`设计的其他部分构成比例关系；
- 使用基数字号时文本段落无法对齐；
- 宋体的中文网页排布中使用最多的是 12 号和 14 号。

### 52\. margin 和 padding 分别适合什么场景使用？

（1）、需要在`border`外侧添加空白且空白处不需要背景（色），或上下相连的两个盒子之间的空白需要相互抵消时，可以使用`margin`；

（2）、需要在`border`内侧添加空白且空白处需要背景（色），或上下相连的两个盒子之间的空白，希望等于两者之和时，可以使用`padding`。

### 53\. 伪元素和伪类的区别和作用？

首先，伪类的效果可以通过添加实际的类来实现，而伪元素的效果可以通过添加实际的元素来实现。所以它们的**本质区别就是是否抽象创造了新元素**。

伪元素/伪对象： 不存在在 DOM 文档中，是虚拟的元素，是创建新元素。代表某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。

    p::first-child {color: red}
    复制代码

伪类：存在`DOM`文档中，逻辑上存在但在文档树中却无须标识的“幽灵”分类。

    a:hover {color: #FF00FF}
    p:first-child {color: red}
    复制代码

🍀**注意**：

- 伪类只能使用“：”；
- 而伪元素既可以使用“:”，也可以使用“::”；
- 因为伪类是类似于添加类所以可以是多个，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾。

### 54\. ::before 和 :after 中双冒号和单冒号有什么区别？

- 在 `CSS` 中伪类一直用 : 表示，如 `:hover`, `:active` 等；
- 伪元素在`CSS1`中已存在，当时语法是用 : 表示，如`:before` 和`:after`；
- 后来在`CSS3`中修订，伪元素用 `::`表示，如 `::before` 和 `::after`，以此区分伪元素和伪类；
- 由于低版本`IE`对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 `:after` 这种老语法表示伪元素；

综上所述：`::before` 是`CSS3`中写伪元素的新语法； `:after`是 `CSS1` 中存在的、兼容`IE`的老语法。

### 55\. 怎么让 Chrome 支持小于 12px 的文字？

    .shrink {
        -webkit-transform: scale(0.8);
        -o-transform: scale(1);
        display: inilne-block;
    }
    复制代码

### 56\. 将多个元素设置为同一行?清除浮动有几种方式?

将多个元素设置为同一行的方法： 使用`float`或`inline-block`；

清除浮动的方式：

- 添加新的元素，应用`clear： both`；
- 父级`div`定义`overflow：hidden`;
- 利用`：after`和`：before`来在元素内部插入两个元素块，从而达到清除浮动的效果。

  .clear { zoom:1; }
  .clear:after {
  content:" ";
  clear:both;
  display:block;
  height:0;
  overflow:hidden;
  visibility:hidden;
  }
  复制代码

### 57\. css hack 概念以及简述几个 css hack?

> **概念**： `CSS hack`是通过在`CSS`样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，`CSS hack`就是让你记住这个标准），以达到应用不同的`CSS`样式的目的。

（1）、图片间隙

在`div`中插入图片，图片会将`div`下方撑大`3px`：

- `hack1`： 将`<div>`与`<img>`写在同一行；
- `hack2`： 给`<img>`添加`display：block`；

`dt` `li` 中的图片间隙：

- `hack1:` 给`<img>`添加`display：block`；

（2）、默认高度，`IE6`以下版本中，部分块元素，拥有默认高度（低于 18px）：

- `hack1`： 给元素添加： `font-size： 0`；
- `hack2`： 声明： `overflow： hidden`；

表单行高不一致：

- `hack1`： 给表单添加声明： `float： left; height: ; border: 0`;

鼠标指针：

- `hack`： 若统一某一元素鼠标指针为手型：`cursor： pointer;`,当 li 内的 a 转化为块元素时，给`a`设置`float`，`IE`里面会出现阶梯状；
- `hack1`： 给`a`添加`display： inline-block`;
- `hack2`： 给`li`添加`float: left`;

### 58\. css2.0 和 css3.0 对比有什么不同？

`CSS3`加强了`CSS2`的功能，增加了新的属性和新的标签，并且删除了一些冗余的标签，在布局方面减少了代码量。以前比较复杂的布局，现在使用一个属性就能解决（例如`columns`等）。在展示型效果方面还加入了更多的效果（如动画，阴影，圆角等），在盒子模型和列表模块都有了改进。但是`CSS3`就兼容性而言，还是有些不足之处是，只能支持一些高版本的浏览器。

### 59\. 块级元素、行内元素和空元素定义？

- **行内元素**：和有他元素都在一行上，高度、行高及外边距和内边距都不可改变，文字图片的宽度不可改变，只能容纳文本或者其他行内元素；
- **块级元素**：总是在新行上开始，高度、行高及外边距和内边距都可控制，可以容纳内敛元素和其他元素；
- **空元素**：在`HTML`元素中，没有内容的 `HTML` 元素被称为空元素。空元素是在开始标签中关闭的。`<br>` 就是没有关闭标签的空元素。

### 60\. 如何解决特定浏览器的样式问题？

建议方案： 主张向前兼容，不考虑向后兼容。根据产品的用户群中各大浏览器，来考虑需要兼容的浏览器。

可以把浏览器分为两类： 一类是历史遗留浏览器，一类是现代浏览器。根据这个分类开发两个版本的网站，然后自己来定义哪些浏览器是历史遗留版本。

在用户使用历史遗留版本的时候，通过通告栏告知用户使用现代浏览器，获取更多的功能，拥有更好的用户体验等（升级）。当用户的浏览器不能兼容时，提示用户只是使用什么版本的浏览器才能使用网站（下载可以兼容的浏览器）。

🍀**注意**：项目开始前就需要确认兼容支持的最低版本是多少，以此设计一个对应的兼容方案。

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="474" height="89"></svg>)

---

### 61\. 🥴 浏览器如何判断元素是否匹配某个 CSS 选择器？

浏览器先产生一个集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到这个选择器都匹配完，还在集合中的元素就匹配这个选择器了。

### 62\. 描述 css reset 的作用和用途？

`Reset`重置浏览器的`CSS`默认属性，浏览器的品种不同，样式不同时，将他们重置，让他们统一。

### 63\. css sprites 是什么？如何使用？

`css`精灵图，把一堆小的图片整合到一张大的图片（png）上，利用`CSS`的`“background-image”`，` “background- repeat”``，“background-position” `的组合进行背景定位`background-position`可以用数字能精确的定位出背景图片的位置，减轻服务器对图片的请求数量。

### 64\. css sprites 的优缺点？

**优点：**

- 利用`CSS Sprites`能很好地减少网页的 http 请求，从而大大提高了页面的性能，这也是`CSS Sprites`最大的优点；
- `CSS Sprites`能减少图片的字节，曾经多次比较过，把 3 张图片合并成 1 张图片的字节总是小于这 3 张图片的字节总和。

**缺点：**

- 在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；
- `CSSSprites`在开发的时候相对来说有点麻烦，需要借助`photoshop`或其他工具来对每个背景单元测量其准确的位置。
- 维护方面：`CSS Sprites`在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的`CSS`，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动`CSS`。

**拓展：** 目前网站开发所用的精灵图（如字体库）一般都是直接用云端，而不是采用这种本地的了，如阿里图标库等。

### 65\. 绝对定位和浮动的区别和应用？

**绝对定位**： 绝对定位脱离标准文档流，它的参考点是文档的左上角或者是右上角。如果有任何父元素有定位属性，此时就可以参考“**子绝父相**”定律来设置自己的定位参考元素。在网页制作过程中很灵活。制作覆盖效果的时候，会大量使用绝对定位。

**浮动**： 浮动脱离标准文档流，通常用于制作并排显示的元素，通常用于大的布局，或者无序列表比如图片的并排。可以使用`clear:both`属性让标准流中的其他元素在此之后依次排列。

### 66\. 当 float 和 margin 同时使用时，如何解决 IE6 的双倍边距？

当浮动的方向和`margin`是同方向的时候，此时 IE6 会在这个方向的第一个元素身上产生双倍`margin`。

解决办法：

（1）、改变`margin`的方向，`float:left; margin-right:20px;` 浮动向左，`margin`向右； （2）、给第一个元素单独写一个类叫做`.content`, 此时`.content{_margin-left:一半的margin;}`； （3）、用`display:inline;`不用浮动了（哈哈哈哈）。

### 67\. 简述什么是内容与表现分离？

首先对于`html`，`css`以及`javascript`，可以这样理解：

把网站理解成一个人，`html`就是构成人体的‘骨架’，`css`就是人体的‘装饰’，比如衣服，饰品等；而`javascript`就相当于人做出的‘动作’，这样就通俗易懂了。

对于内容和表现分离，小编的理解是：尽量不要再`html`中插入行内样式，尽量将 css 抽成一个独立的模块，实现`html`‘骨架’和样式的分离，利于搜索引擎的同时，也便于后期维护。

### 68\. CSS 怎样判断不同分辨率显示不同宽度布局，从而实现自适应宽度？

- 使用百分比布局，用百分比来写宽度、`marign`、`padding`；
- 使用`rem`做单位，适当的写` js``让html `根元素的字号随着浏览器宽度的变化而等比例变化；
- 使用媒体查询让不同宽度的浏览器使用不同的样式表。

### 69.rem 为什么可以缩放，以什么为基准？其优缺点有哪些？

` rem``以html `的字号为基准，比如`2rem`，而`html`的字号时`16px`，此时`rem`就是`32px`。可以写一段`js`让`html`根元素的字号随着浏览器宽度的变化而等比例变化，此时造成页面等比例缩放的现象。

**优点**：

相对于`em`的好处来说，不会发生逐渐增大或者减小字体尺寸的情况，因为始终集成根元素的字体大小；`rem`单位不仅仅是可应用于字体大小，还可以用于设定高度等其它大小，使页面可以适配不同屏幕尺寸。

🍀**注意**： `rem` 一般只用于移动端。

### 70\. 5 条常见的 Firefox 和 IE 的脚本兼容的问题。

- **绑定监听**： `IE`是`attatchEvent()` 、 `firefox`是`addEventListener()`;
- **计算样式**：`IE`是`currentStyle`、 `firefox`是`getComputedSyle`;
- **滚动事件**：`IE`是`MouseWheel`、 `firefox`是`onmousewheel`；
- **表单元素**：`IE`是 `document.forms(”formname”)` ， `firefox`是`document.forms["formname"]`；
- **事件对象**： `IE`是`window.event`属性， `firefox`必须给事件处理函数注入实参`event`；

![](https://user-gold-cdn.xitu.io/2020/6/5/17282053da3df444?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

---

### 71\. 🥳css 的优先级如何计算？

巩固一下：

分类

优先级

元素选择符

1

class 选择器

10

id 选择器

100

元素标签

1000

（1）、`!important`声明的样式优先级最高，若有冲突会再进行计算；

（2）、优先级相同时，以最后出现的样式为准；

（3）、继承得到的样式的优先级是最低的。

### 72\. 回顾 position 的值及其作用？

- `static`（默认）：按照正常文档流进行排列；
- `relative`（相对定位）： 不脱离文档流，参考自身静态位置通过`top`, `bottom`, `left`, `right`定位；
- `absolute`（绝对定位）： 参考距离最近一个不为`static`的父级元素通过`top`, `bottom`, `left`, `right`定位；
- `fixed`（固定定位）： 所固定的参照对象是可视窗口。

### 73.有哪几种高等布局？

- 假等高列：使用背景图片，在列的父元素上使用这个背景图进行 Y 轴的铺放，从而实现一种等高列的假象；
- 给容器的`div`使用单独的背景色（固定布局）（流体布局）：用元素中的最大高度撑起其他容器的高度；
- 创建带边框的两列等高布局： 用`border-left`来做，之鞥呢使用两列；
- 使用正`padding`和负`margin`对冲实现多列布局方法： 在所有列中使用的上，下`padding`和负的上，下`margin`，并在所有列外面加上一个容器，设置`overflow： hidden`，把溢出的背景切掉。
- 使用边框和定位模拟列等高： 但不能使用在多列；
- 模仿表格布局等高列效果： 兼容性不好，在`ie6-7`中无法正常运行；

### 74\. :link、:visited、:hover、:active 的执行顺序是怎么样的？

`L-V-H-A`，`l(link)ov(visited)e h(hover)a(active)te`，即用喜欢和讨厌两个词来概括。

### 75\. 经常遇到的浏览器兼容性有哪些？如何解决？

- 浏览器默认的`margin`和`padding`不同；
- `IE6`双边距`bug`；
- 在`IE6-7`中元素高度超出自己设置的高度。原因是 IE8 以前的浏览器中会给元素设置偶人的行高的高度所导致的；
- `min-height`在`IE6`下不起作用；
- 透明性`IE`用`filter：Alpha（Opacity=60）`,而其它主流浏览器用`opacity： 0.6`；
- `input`边框问题，去掉`input`边框一般用`border：none；`就可以但是由于`IE6`在解析`input`样式时`bug`（优先级问题），在`IE6`下无效；

### 76\. 为什么要语义化以及对于标签语义化的理解？

原因： **为了在没有 css 的情况下，页面也能呈现出很好的内筒结构和代码架构（可以理解为为了裸奔时好看哈哈哈）**。

理解：

- 去掉或者丢失样式的时候能够让页面呈现清晰的结构；
- 有利于`SEO`，可以和搜索引擎建立良好的沟通，有助于爬虫抓取更多的有效信息（爬虫依赖于标签来确定上下文和各个关键字的权重）；
- 方便其他设备解析（如屏幕阅读器，盲人阅读器，移动设备等），以意义的方式来渲染网页；
- 便于团队的开发和维护，语义化更具有可读性，遵循`W3C`标准的团队都遵循这个标准，可以减少代码差异化；

### 77\. 常见的 CSS 布局有几种？

常见的`CSS`布局有： **固定布局**、**流式布局**、**弹性布局**、**浮动布局**、**定位布局**、**margin 和 padding**。

### 78\. position 的 absolute 与 fixed 共同点与不同点？

相同点：

- 改变行内元素的呈现方式，`display`被设置为`block`；
- 让元素脱离普通流，不占据空间；
- 默认会覆盖到非定位元素上；

不同点：

- `absolute`的“根元素”是可以设置的，而`fixed`的“根元素”固定为浏览器窗口；
- 当滚动网页时，`fixed`元素与浏览器窗口之间的距离是不变的。

### 79\. CSS 哪些属性可以继承？哪些属性不可以继承？

- 可以继承的样式属性： `font-size`、`font-family`、`color`、`list-style`、`cursor`、`ul`, `li`, `dl`, `dd`, `dt`;
- 不可继承的样式属性： `width`、`height`、 `border`、 `padding`、 `margin`、 `background`；

🍀**注意**： 为了便于理解，小编觉得可以大致理解为**字体相关的样式可以继承，与尺寸相关的样式不可继承**。

### 80.使用过的 CSS 预处理器？

`CSS`预处理器的基本思想： 为`CSS`增加了一些变量的特性（变量，判断逻辑和函数等）。

开发者使用这种语言进行 web 页面上样式设计，再编译成正常的`css`文件使用。使用 CSS 预处理器，可以使`CSS`更加简洁，适应性更强，可读性更佳，无需考虑兼容性。最常用的`CSS`预处理器语言包括： `Sass(Scss)`和`Less`。

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="474" height="89"></svg>)

---

### 81\. 🤧 设置元素浮动后，该元素的 display 值会如何变化？

设置元素浮动后，该元素的`display`值自动变成`block`。

### 82\. 行内元素有哪些?块级元素有哪些? 空(void)元素有那些?

- 行内元素： `a`、`b`、 `span`、`img`、 `input`、 `strong`、 `select`、 `label`、 `em`、 `button`、 `textarea`；
- 块级元素： `div`、 `ul`、 `li`、 `dl`、 `dt`、 `dd`、 `p`、 `h1-h6`、 `blockquote`；
- 空元素： 即没有实际内容内容的`html`元素，如：`br`、`meta`、`hr`、 `link`、 `input`、 `img`；

### 83\. box-sizing 属性？

用来控制元素的盒子模型的解析模式，默认为`content-box`。

- `content-box: W3C`的标准盒子模型，设置元素的`height/width`属性指的是`content`部分的宽/高；
- `border-box`：IE 传统盒子模型。设置元素的`height/width`属性指的是`border + padding + content`部分的高/宽；

### 84\. CSS3 动画比基于脚本的动画有哪些优势？

跟脚本动画相比，使用`CSS3`动画具有以下优势：

- 易于使用，任何人都可以在不了解`javascript`的情况下创建它们；
- 即使在合理的系统负载下也能很好的执行。
- 由于简单的动画在`javascript`中的效果比较差，因此渲染引擎使用跳帧技术来使动画流畅进行；
- 允许浏览器控制动画序列，通过建撒谎哦在当前不可见的选项卡中执行的动画的更新频率来优化性能和效率；

### 85\. 如何优化网页的打印样式？

`<link rel="stylesheet" type="text/css" media="screen(或者print、tv等) href="aaa.css">`

🍀**注意**，在打印样式表也应该注意以下几点：

- 打印样式表中最好不要用背景图片，因为打印机不能打印 CSS 中的背景图。如果坚持要显示图片，可以使用`html`插入到页面中；
- 最好不要使用像素作为单位，因为打印样式表要打印出来的是实物，建议使用`pt/cm`;
- 隐藏掉不必要的内容。（如`@print content{display: none}`）;
- 打印样式表中不建议使用浮动属性（建议少用），因为它们会消失。

### 86\. React Native 中的样式与 css 的区别？

- `React Native` 的样式基本上是实现了 `CSS` 的一个子集，并且属性名不完全一致，所以当你开始在考虑兼容`React Native` 端之前，可以先简要了解一下 `React Native` 的样式。
- 这些样式名基本上是遵循了 `web` 上的 `CSS`的命名，只是按照 `JS` 的语法要求使用了驼峰命名法。
- `RN`使用 `JavaScript` 来写样式，所有核心组件都接受名为`style`的属性，相当于`css`的行内样式。
- 在 `React Native`中使用 Flexbox 规则来指定某个组件的子元素的布局。`Flexbox` 可以在不同屏幕尺寸上提供一致的布局结构。因此，如果你要考虑 `React Native` 端，那你的样式布局就得采用 `Flex` 布局。

### 87\. style 标签写在 body 后与 body 前有什么区别？

一般情况下，页面加载时自上而下的。将`style`标签至于`body`之前，为的是先加载样式。

若是写在`body`标签之后，由于浏览器以逐行方式对 html 文档进行解析，当解析到写在写在文档尾部的样式表时，会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后会重新渲染，在`windows`的`IE`下可能会出现`FOUC`现象（页面闪烁）。

### 88\. CSS 属性 overflow 属性定义溢出元素内容区的内容会如何处理?

- 参数是`scroll`的时候，一定会出滚动条；
- 参数是`auto`的时候，子元素内容大于父元素时出现滚动条；
- 参数是`visible`的时候，溢出的内容出现在父元素之外；
- 参数是`hidden`的时候，溢出隐藏；

### 89\. BFC、IFC、GFC、FFC 是什么？

- `Block formatting context(BFC)`--块级格式化上下文；
- `Inline formatting context(IFC)`--内联格式化上下文；
- `Crid formatting context(GFC)`--网格布局格式化上下文；
- `Flex formatting context(FFC)`--自适应格式化上下文；

### 90\. 对于使用图片，需要注意什么？

- 优化图片；
- 尽量避免在`html`中使用压缩图片；
- 使用恰当的图片格式；
- 使用`css sprites`技巧对图片优化；

![](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="474" height="89"></svg>)

---

### 91.😯 如何优化图像以及图像格式有什么区别？

**优化图像**：

- 不用图片，尽量使用`CSS3`代替。对于一些要实现的修饰效果，例如阴影，圆角，半透明等，可以用`CSS3`完成；
- 尽可能使用矢量图`SVG`代替位图。对于绝大多数图案和图标等，矢量图更小，而且可以缩放而无需生成多套图。现代的主流浏览器大多数都能稳定的支持`SVG`。

**图像格式区别**：

- 矢量图： 图标字体，如`font-awesome`、`svg`；
- 位图： `GIF`、`jpg（JPEG）`、`png`；

矢量图和位图的区别：

- `PNG`：它可以细分为三种格式： `PNG8`，`PNG24`，`PNG32`。后面的数字代表这种`PNG`格式最多可以索引和存储的颜色值；
- `JPG`: 一种大小与质量相对平衡的压缩图片格式。适用于允许轻微失真的色彩丰富的照片，不适用于色彩简单（色调少）的图片，比如图标啊，`logo`等；
- `GIF`： 一种无损的，8 位图片格式。具有支持动画，索引透明，压缩等特性。使用色彩简单的图片。

**优点**： 能保证在最不失真的情况下尽可能压缩图像文件的大小；

**缺点**： 对于需要高保真的较为复杂的图像，`PNG`虽然能无损压缩，但是图片较大，不适合应用在 web 页面上；

### 92\. position:fixed;在手机端下无效怎么处理？

`fixed`的元素实现相对于整个页面是固定位置的，当在屏幕上滑动时是在滑动整个`viewport`。原来的网页还在，fixed 也没有变过位置，所以说并不是手机端不支持`fixed`，只是`fixed`元素不是相对于手机屏幕固定的，因此我们按照以下方式来设计：

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/>
    复制代码

### 93\. css 样式引入方式的优缺点对比

- 内嵌样式： 优点： 方便书写，权重高；缺点： 没有做到结构和样式分离；
- 内联样式： 优点：结构样式相分离； 缺点：没有彻底分离；
- 外联样式： 优点： 完全实现了结构和样式相分离； 缺点： 需要引入才能使用；

### 94\. border:none;与 border:0;有什么区别？

**首先是性能差异**：

- `{border：0;}`: 把`border`设置为 0 像素，虽然在页面上看不到，但是按`border`默认值理解，浏览器依然对`border-width/border-color`进行了渲染，即已经占用内存值；
- `{border：none；}`被理解为`border-style:none`。`boder:0`;比`border:none`多渲染了一个`border-width:0`,也就是为什么`border:none`的性能要比`border:0`高；

**兼容性差异**：

- `{border:none;}`当`border`为`“none”`时似乎对`IE6/7`无效边框依然存在当`border`为“0”时，感觉比`“none”`更有效，所有浏览器都一致把边框隐藏。

### 95\. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？

- `display`属性规定元素应该生成的框的类型；
- `position`属性规定元素的定位类型；
- `float`属性是一种布局方式，定义元素往哪个方向浮动；

**叠加结果**：有点类似于优先机制。`position`的值\-\- `absolute/fixed`优先级最高，有他们在时，`float`不起作用，`display`值需要调整。`float`或者`absolute`定位的元素，只鞥是块元素或者表格。

### 96\. 什么是 critical CSS？

`Critical CSS`是一种提取首屏中 `CSS` 的技术，以便尽快将内容呈现给用户。这是快速加载网页首屏的好方法。

核心思路：

（1）、抽取出首页的`CSS`；

（2）、用行内 css 样式，加载这部分的`css(critical CSS)`;

（3）、等到页面加载完之后，再加载整个`css`，会有一部分`css`与`critical css`重叠；

### 97\. 什么是回流（重排）和重绘以及其区别？

- 回流（重排），`reflow`:当`render tree`中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变时而需要重新构建；
- 重绘`（repaint`）:当`render tree`中的一些元素需要更新属性，而这些属性只影响元素的外观，风格，而不会影响布局时，称其为**重绘**，例如颜色改变等。

🍀**注意**：**每个页面至少需要引发一次重排+重绘，而且重排（回流）一定会引发重绘**。

触发重排（回流）的条件：

- 增加或者删除可见的`dom`元素；
- 元素的位置发生了改变；
- 元素的尺寸发生了改变，例如边距，宽高等几何属性改变；
- 内容改变，例如图片大小，字体大小改变等；
- 页面渲染初始化；
- 浏览器窗口尺寸改变，例如`resize`事件发生时等；

### 98\. css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？

- 垂直方向： `line-height`；
- 水平方向： `letter-spacing`；

🍀**注意**： `letter-spacing`还可以用来消除`inline-block`元素间的换行符空格间隙等问题。

### 99\. 对 WEB 标准以及 W3C 有什么理解与认识？

- 标签闭合，标签小写，不乱嵌套；
- 提高搜索机器人的搜索几率；
- 使用外链`CSS`和`JS`脚本；
- 结构行为标签分离；
- 文件下载和页面速度更快；
- 内容能被更多的用户以及更广泛的设备访问；
- 更少的代码和组件，易于维护，改版方便；
- 不需要动页面内容，同时提供打印版本也不需要复制内容，提高网站的易用性；
