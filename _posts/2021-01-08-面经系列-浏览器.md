---
layout: post
title: "面经系列-浏览器"
date: 2021-01-08
tags: 随笔

color: "rgb(154,133,255)"
---

### 浏览器内核的理解

*   主要分两个部分：`渲染引擎`、`js引擎`
*   `渲染引擎：`负责取得网页的内容（html css img ...），以及计算网页的显示方式，然后会输出至显示器或者打印机。浏览器的内核不同对于网页的语法解释也不同，所以渲染的效果也不一样
*   `js引擎：`解析和执行javascript 来实现网页的动态效果
*   最开始渲染引擎和js引擎并没有区分的很明确，后来js引擎越来越独立，内核就倾向于只值渲染引擎
*   `IE : trident` 内核
*   `Firefox ： gecko` 内核
*   `Safari : webkit` 内核
*   `Opera` :以前是 `presto` 内核， `Opera` 现已改⽤`Google - Chrome` 的 `Blink` 内核
*   `Chrome:Blink` (基于 `webkit` ，`Google与Opera Software`共同开发)

### HTTP 请求+作用？

*   `Get` 方法：发送一个请求来获取服务器资源
*   `POST` 方法：向服务器提交数据
*   `PUT` 方法：与`POST`方法很像，也是提交数据，但`PUT`制定了资源在服务器上的位置，常用在修改数据
*   `HEAD` 方法：只请求页面的首部信息
*   `DELETE` 方法：删除服务器上的资源
*   `OPTIONS` 方法：用于获取当前`URL`支持的请求方式
*   `TRACE` 方法：用于激活一个远程的应用层请求消息回路
*   `CONNECT` 方法：把请求链接转换到透明的`TCP/IP`的通道

### HTTP状态吗

*   `1XX` ：信息状态吗
    *   `100 continue` 继续，⼀般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息
*   `2XX` ：成功状态吗
    *   `200 ok` 正常返回信息
    *   `201 created` 请求成功并且服务器创建了新资源
    *   `202 accepted` 服务器已经接收请求，但尚未处理
*   `3XX` ：重定向
    *   `301 move per` 请求的网页已经永久重定向
    *   `302 found` 临时重定向
    *   `303 see other` 临时冲重定向，且总是使用get请求新的url
    *   `304 not modified` 自从上次请求后，请求的网页未修改过
*   `4XX` ：客户端错误
    *   `400 bad request` 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求
    *   `401 unauthorized` 请求未授权
    *   `403 forbidden` 禁止访问
    *   `404 not found` 找不到如何与url匹配的资源
*   `5XX` ：服务器错误
    *   `500 internal server error` 最常见的服务器端的错误
    *   `503 service unacailable` 服务器端暂时无法处理请求（可能是过载活维护）

### 从浏览器地址栏输入URL后发生了什么？

#### 基础版本

*   1.的浏览器根据请求的 `URL` 交给 `DNS` 域名解析，找到真实 `IP` ，向服务器发起请求；
*   2.服务器交给后台处理完成后返回数据，浏览器接收⽂件`（ HTML、JS、CSS 、图象等）`；
*   3.浏览器对加载到的资源`（ HTML、JS、CSS 等）`进⾏语法解析，建⽴相应的内部数据结构`（如 HTML 的 DOM ）`；
*   4.载⼊解析到的资源⽂件，渲染⻚⾯，完成。

#### 详细版

*   1.从浏览器接收 `url` 到开启⽹络请求线程（这⼀部分可以展开浏览器的机制以及进程与线程之间的关系）
*   2.开启⽹络线程到发出⼀个完整的 `HTTP` 请求（这⼀部分涉及到dns查询， `TCP/IP` 请求，五层因特⽹协议栈等知识）
*   3.从服务器接收到请求到对应后台接收到请求（这⼀部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
*   4.后台和前台的 `HTTP` 交互（这⼀部分包括 `HTTP` 头部、响应码、报⽂结构、 `cookie` 等知识，可以提下静态资源的 `cookie` 优化，以及编码解码，如 `gzip` 压缩等）
*   5.单独拎出来的缓存问题， `HTTP` 的缓存（这部分包括`http缓存头部`， `ETag ， catchcontrol` 等）
*   6.浏览器接收到 `HTTP` 数据包后的解析流程（解析 `html` -词法分析然后解析成 `dom` 树、解析 `css` ⽣成 `css` 规则树、合并成 `render` 树，然后 `layout 、 painting` 渲染、复合图层的合成、 `GPU` 绘制、外链资源的处理、 `loaded 和 DOMContentLoaded` 等）
*   7.`CSS` 的可视化格式模型（元素的渲染规则，如包含块，控制框， `BFC` ， IFC 等概念）
*   8.`JS` 引擎解析过程（ `JS` 的解释阶段，预处理阶段，执⾏阶段⽣成执⾏上下⽂， `VO` ，作⽤域链、回收机制等等）
*   9.其它（可以拓展不同的知识模块，如跨域，`web`安全， `hybrid` 模式等等内容）

#### 详细升级版

*   1.在浏览器地址栏输⼊`URL`
*   2.浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
    *   2.1 如果资源未缓存，发起新请求
    *   2.2 如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验证。
    *   2.3 检验新鲜通常有两个`HTTP`头进⾏控制 `Expires` 和 `Cache-Control` ：
        *   2.3.1 `HTTP1.0`提供`Expires`，值为⼀个绝对时间表示缓存新鲜⽇期
        *   2.3.2 `HTTP1.1`增加了`Cache-Control: max-age=`,值为以秒为单位的最⼤新鲜时间
*   3.浏览器解析`URL`获取协议，主机，端⼝，`path`
*   4.浏览器组装⼀个`HTTP（GET）`请求报⽂
*   5.浏览器获取主机`ip地址`，过程如下：
    *   5.1 浏览器缓存
    *   5.2 本机缓存
    *   5.3 hosts文件
    *   5.4 路由器缓存
    *   5.5 ISP DNS缓存
    *   5.6 DNS递归查询（可能存在负载均衡导致每次IP不一致）
*   6.打开一个`socket`与目标`IP地址`，端口建立TCP链接，`三次握手`如下：
    *   6.1 客户端发送一个`TCP的SYN=1，Seq=X`的包到服务器端口
    *   6.2 服务器发回`SYN=1，ACK=x+1,Seq=Y`的相应包
    *   6.3 客户端发送`ACK=Y+1，Seq=z`
*   7.`TCP`链接建立后发送`HTTP`请求
*   8.服务器接收请求后解析，将请求转发到服务器程序，如虚拟主机使用`HTTP Host`头部判断请求的服务程序
*   9.服务器检测`HTTP`请求头是否包含缓存验证信息，如果验证缓存新鲜，返回304等对应状态
*   10.出合理程序读取完整请求并准备`HTTP`相应，可能需要查询数据库等操作
*   11.服务器将相应报文通过`TCP`链接发送回浏览器
*   12.浏览器接收`HTTP`相应，然后根据情况选择关闭`TCP`链接或者保留重用，关闭TCP链接的四次握手如下：
    *   12.1 主动方发送`Fin=1,ACK=z,Seq=x`报文
    *   12.2 被动方发送`ACK=X+1,Seq=Y`报文
    *   12.3 被动方发送`Fin=1,ACK=X,Seq=Y`报文
    *   12.4 主动方发送`ACK=Y,Seq=x` 报文
*   13.浏览器检查相应状态码
*   14.如果资源可缓存，进行缓存
*   15.对相应进行解码
*   16.根据资源类型决定如何处理
*   17.解析`HTML`文档，构建`DOM`树，下载资源，构建`CSSOM`树，执行js脚本，这些操作每月严格的先后顺序
*   18.构建DOM树：
    *   18.1 Tokenizing：根据HTML规范将字符流解析为标记
    *   18.2 Lexing：词法分析将标记转换为对象并定义属性和规则
    *   18.3 DOM construction：根据HTML标记关系将对象组成DOM树
*   19.解析过程中遇到图⽚、样式表、js⽂件，启动下载
*   20.构建`CSSOM`树：
    *   20.1 `Tokenizing`：字符流转换为标记流
    *   20.2 `Node`：根据标记创建节点
    *   20.3 `CSSOM`：节点创建CSSOM树
*   21.  根据`DOM树和CSSOM树`构建渲染树
    
    *   21.1 从`DOM树`的根节点遍历所有可⻅节点，不可⻅节点包括：1） `script , meta` 这样本身不可⻅的标签。2)被css隐藏的节点，如 display: none
    *   21.2 对每⼀个可⻅节点，找到恰当的`CSSOM`规则并应⽤
    *   21.3 发布可视节点的内容和计算样式
*   22.js解析如下
    *   22.1 浏览器创建`Document对象`并解析`HTML`，将解析到的元素和⽂本节点添加到⽂档中，此时`document.readystate为loading`
    *   22.2 HTML解析器遇到没有`async和defer的script时`，将他们添加到⽂档中，然后执⾏⾏内或外部脚本。这些脚本会同步执⾏，并且在脚本下载和执⾏时解析器会暂停。这样就可以⽤`document.write()`把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的⽂档内容
    *   22.3 当解析器遇到设置了`async属性的script`时，开始下载脚本并继续解析⽂档。脚本会在它下载完成后尽快执⾏，但是解析器不会停下来等它下载。异步脚本禁⽌使⽤`document.write()`，它们可以访问⾃⼰script和之前的⽂档元素
    *   22.4 当⽂档完成解析，`document.readState变成interactive`
    *   22.5 所有`defer脚本`会按照在⽂档出现的顺序执⾏，延迟脚本能访问完整⽂档树，禁⽌使⽤`document.write()`
    *   22.6 浏览器在`Document`对象上触发`DOMContentLoaded事件`
    *   22.7 此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊并且所有异步脚本完成载⼊和执⾏，`document.readState变为complete，window触发load事件`
*   23.显示⻚⾯（HTML解析过程中会逐步显示⻚⾯）

### cookies ， sessionStorage 和 localStorage 的区别

*   `cookie` 是⽹站为了标示⽤户身份⽽储存在⽤户本地终端上的数据（通常经过加密）
*   `cookie`数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递（优化点）
*   `sessionStorage` 和 `localStorage` 不会⾃动把数据发给服务器，仅在本地保存
*   存储⼤⼩：
    *   `cookie` 数据⼤⼩不能超过4k
    *   `sessionStorage 和 localStorage` 虽然也有存储⼤⼩的限制，但⽐ cookie ⼤得多，可以达到5M或更⼤
*   有期时间：

`localStorage` 存储持久数据，浏览器关闭后数据不丢失除⾮主动删除数据

`sessionStorage` 数据在当前浏览器窗⼝关闭后⾃动删除

`cookie 设置的 cookie` 过期时间之前⼀直有效，即使窗⼝或浏览器关闭

### 浏览器缓存

> 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下

*   先根据这个资源的⼀些 `http header` 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
*   当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另⼀些 `request header`验证这个资源是否命中协商缓存，称为 `http` 再验证，如果命中，服务器将请求返回，但不返回资源，⽽是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
*   强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。
*   当协商缓存也没命中时，服务器就会将资源发送回客户端。
*   当 `ctrl+f5` 强制刷新⽹⻚时，直接从服务器加载，跳过强缓存和协商缓存；
*   当 `f5` 刷新⽹⻚时，跳过强缓存，但是会检查协商缓存；

[强缓存-协商缓存：这篇文章介绍挺细的：https://juejin.cn/post/6844903763665240072#heading-5](https://juejin.cn/post/6844903763665240072#heading-5)