### Vue面试
#### 1.为什么要有vue，从历史角度谈谈
因为vue大大提高了前端开发的效率，vue带来了前端开发模式的转变，传统的前端开发是使用html+css搭建前端页面，使用js或jquery等技术进行页面的交互逻辑，然后使用ajax技术进行与后台的通信，后台返回数据浏览器进行页面的渲染。
     使用vue之后我们可以进行数据的双向绑定，使用vue-router处理页面路由，使用vue处理各组件直接的通信，使用vue-resource或者axios处理http请求，使用element-ui或者mint-ui来搭建前端页面
     
-  优点:目前路西的单页面流行框架，减轻服务器压力，前后端完全分离，比augular更省资源
- 缺点:不利于seo，(对国内搜索引擎来说，比如百度)，第一次加载速度较慢
- 解决:页面静态化，可以使爬虫抓取页面
#### 2.vue的核心内容:数据双向绑定 MVVM思想 组件化开发 虚拟DOM树 自定义指令 生命周期
- 为什么要有指令?操作DOM，放到页面上
- 1.为了把我们得到的数据放到页面上
- 2.大牛把操作DOM方法封装，让程序员专注于操作数据
#### 3.vue的基本用法
#####    3.1 常见指令
- v-if 根据表达式的值在dom中生成或移除一个元素
- v-show 根据表达式的值显示或隐藏html元素
- v-if和v-show都可以用来控制页面的隐藏和显示，他们的区别在于，v-if是直接在页面中删除某个元素，v-show是改变元素的display属性来控制隐藏或者显示
- v-else是js中else的意思，必须跟着v-if或者v-show使用
- v-model 用来在表单控件元素上创建双向数据绑定
- v-bind 用来响应更新html新特性，将一个或多个属性绑定到表达式上
- v-on 用于绑定事件监视器
- v-text和v-html以及{{}}都是用来实现数据绑定的，v-text和v-html的区别在于会不会输出thml标签
使用{{}}的话，在网速较慢的情况下{{}}会显示出来，可以使用v-cloak来解决这个问题
##### 3.2 组件怎么做的？
在vue中定义全局组件有三种方式
  1.使用vue.extend({})定义全局组件，然后再通过vue.component把vue.extend定义的组件注册到vue全局上
  2.直接用vue.component("引用组件的名称”,{组件实际的定义模板})
  3.vue.component(“组件名称”,{template:模板id}
##### 3.3用户怎么请求数据?
使用vue-resource或者使用axios

```js
getData(){this.$http
  .get("http://vue.studyit.io/api/ getnewslist").then(res =>{
						console.log(res.body);
						this.list = res.body.message
					})
					.catch(err =>{console.log(err);})
			},
postData(){this.$http
  .post("http://vue.studyit.io/api/postcomment/17",
  {content:"完美！"},
  {emulateJSON:true})
   .then(resp =>{
						console.log(resp.body)})}
```
##### 3.4 用什么做路由
 官方提供了vue-router插件，路由是浏览器中的哈希值(#hash)与展示视图内容(template)之间的对应规则
   vue中的路由是:hash与component的对应关系
##### 3.5父组件给子组件传值
  父--->子:用props；（单项数据流）组件想要使用父组件的数据，我们需要通过子组件的prop选项来获得父组件传过来的数据，当父组件的name发生改变，子组件也会自动地更新视图，如果是改动了子组件中的prop的值得时候，父组件中的值是不会响应的变化的，如果要修改prop，就把prop赋值给一个局部变量，然后需要修改的话就修改这个局部变量，而不影响prop
#####  3.6子组件给父组件传值
子-->父:用$.emit(event ,[..args]) 父组件用$.on接收,通过在父组件 $on(eventName) 监听自 定义事件，当子组件里 $emit(eventName) 触发该自定义事件的时候，父组件执行相应的操作方法。

##### 3.7兄弟组件间传值
兄弟-->兄弟 :用vuex(状态管理模式)和event.bus( 空实例对象)

```

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <div id="app">
    <aaa></aaa>
    <bbb></bbb>
  </div>

  <script src="./vue.js"></script>
  <script>
    // 非父子组件通讯：

    var bus = new Vue()

    var vm = new Vue({
      el: '#app',
      data: {
      },

      // 通过 components 来创建属于该实例的局部组件
      components: {
        aaa: {
          template: `
            <div>
              <h1>组件A</h1>
              <button @click="fn">传递数据给组件B</button>
            </div>
          `,

          created() {
            bus.$emit('bfn', '组件A说：你好组件B')
          },

          methods: {
            fn() {
              // 触发事件，传递数据
              bus.$emit('bfn', '组件A说：你好组件B')
            }
          }
        },

        bbb: {
          template: `
            <div>
              <hr>
              <h1>组件B: {{ msg }}</h1>
            </div>
          `,

          data() {
            return {
              msg: ''
            }
          },

          // 在钩子函数中，绑定事件，这样以进入页面，事件就绑定好了，等待组件A触发
          created() {
            // 绑定事件，接受数据
            bus.$on('bfn', data => {
              this.msg = data
            })
          }
        }
      }
    })
  </script>
</body>

</html>
```
#### 4. vuex 里面有一个仓库是state(数据仓库)改变数据仓库数据的一些方法motation.异步的
 和 motation(里面放同步的方法)

##### 4.1 双向数据绑定的原理
          答：vue中数据的双向绑定采用的时候，数据劫持的模式。其实主要是用了Es5中的Object.defineProperty;来劫持每个属性的getter,和setter
###### vue 执行的过程（双向数据绑定的原理解析）：

-  1 根据传入的 el 配置项，找到页面中需要被Vue管理的内容区域
- 2 遍历所有的后代元素，收集出现的所有指令（v-model）和表达式（{{}}）
- 3 遍历传入 data 中的数据，分别通过 Object.defineProperty() 实现每个数据的get/set
- 4 每个数据的get/和set中，分别与页面中使用该数据的指令和表达式对应起来
- 5 将来当数据改变的时候，通过 设定好的set，将数据的变化同步到页面中
##### 4.2 路由的原理。
          答：
main.js入口配置好路由,在app.vue 根组件中引入router-view标签,在router组件中配置各种路由
location.hash hashchange事件      
在访问google plus 和网易m站时，细心的用户也许会发现页面之间的点击是通过ajax异步请求的，同时页面的URL发生了了改变。并且能够很好的支持浏览器的前进和后退。不禁让人想问，是什么有这么强大的功能呢？

HTML5里引用了新的API，就是history.pushState和history.replaceState，就是通过这个接口做到无刷新改变页面URL的。

对应history.pushState和history.replaceState的具体用法可以参考下面这几篇文章：

HTML5 history新特性pushState、replaceState
传统的ajax的问题
虽然ajax可以无刷新改变页面内容，但无法改变页面URL
为了更好的可访问性，内容发生改变后，改变URL的hash。但是hash的方式不能很好的处理浏览器的前进、后退等问题 有的浏览器引入了onhashchange的接口，不支持的浏览器只能定时去判断hash是否改变
ajax的使用对搜索引擎很不友好，往往蜘蛛爬到的区域是空的
为了解决传统ajax带来的问题，HTML5里引入了新的API，即：history.pushState, history.replaceState 可以通过pushState和replaceState接口操作浏览器历史，并且改变当前页面的URL。
##### 4.3 数据请求的原理。
          答：axios 原理也是ajax。
  3.3 vue2.0源码的实现过程
####  5.工作中遇到的bug?
浏览器兼容，移动端兼容问题
#### 6.模块化与组件化
模块化开发以js文件功能分类，
组件化开发把js,html,css放到一个文件里，功能独立
vue~resource支持jsonp,vue2.0以上不支持
#### 7.axio跨域问题怎么解决？
需要封装jsonp,或者用cros
服务器设置，
跨域：jsonp支持低版本浏览器,
        cros高版本浏览器,反向代理
服务器允许跨域的代码：

//允许所有的域名访问这个接口
header("Access-Control-Allow-Origin:*");
//允许www.study.com这个域名访问这个接口
header("Access-Control-Allow-Origin:http://www.jepson.com");
vue获取更新后的数据

ajax
返回出现error,datatype没设置
模板引擎的原理是利用正则表达式定义标签替换{}语句中的内容
，模板引擎的缺点不利于seo,无法准确定位错误

h5css3
browersync调试工具
httpcache离线缓存

fiddler拦截后端请求，模拟数据请求返回

测试前后端数据
get请求直接在url地址栏，也可以用fiddler,postmessage